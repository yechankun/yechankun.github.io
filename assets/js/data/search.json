[ { "title": "Git 소개 및 기본 명령어", "url": "/posts/Git-%EC%86%8C%EA%B0%9C-%EB%B0%8F-%EA%B8%B0%EB%B3%B8-%EB%AA%85%EB%A0%B9%EC%96%B4/", "categories": "개발, Git", "tags": "깃, Git, 도구, 깃허브, 미러링, 깃랩, 복사", "date": "2023-04-25 21:44:00 +0900", "snippet": "Git은 현존 최고의 버전컨트롤 방식이다! 💡 깃은 형상 관리 도구(Configuration Management Tool)이자소스 제어 관리 도구 (Source-control management Tool)입니다. 파일 변화를 시간에 따라 기록 → 원할 때 꺼내서 사용진짜 최종의…최종.. Jira 등의 소프트웨어를 제공하는 Atlassian 공식, 왜 Git을 써야하는가?Why Git | Atlassian Git Tutorial 기능 분기 워크플로 분산 개발 SVN은 개별 개발자만의 개발 이력 X 풀 리퀘스트 지역사회 - 이미 깃은 널리 알려짐 빠른 릴리즈 - 모놀리식 릴리즈보다 빠른 마이크로서비스 릴리즈가 가능함 명령어의 중요성 💡 현업에선 GUI도 많이 쓰지만 Git Bash 명령어를 모르고 쓰는 경력자 분들은 없습니다.모든 명령어를 사용 방법까지 하나하나 알고 있을 필요 X→ 어떤 명령이 있는지, 어떤 상황에서 어떤 방식을 쓸 수 있는지 이해하는 것이 중요합니다주요 명령어 모음설정 및 초기화 전역 사용자명/이메일 구성하기$ git config - -global user.name “Your name”$ git config - -global user.email “Your email address” 저장소별 사용자/이메일 구성$ git config user.name “Your name”$ git config user.email “Your email address” 각종 조회# 전역 설정 정보 조회$ git config - -global - -list# 저장소별 설정 정보 조회$ git config - -list 새로운 저장소 초기화 또는 복제# 초기화$ mkdir /path/newDir$ cd /path/newDir$ git init# 저장소 복제. []는 생략 가능-현재 위치로 복제$ git clone &amp;lt;저장소 url&amp;gt; [폴더 위치]기본 사용법# 파일 스테이징 및 커밋$ git add &amp;lt;파일&amp;gt;$ git commit -m &quot;&amp;lt;메시지&amp;gt;&quot;# 파일 일부 스테이징$ git add -p &amp;lt;파일&amp;gt; [파일...]# 대화 모드로 파일 추가git add -i브랜치 관련 명령# 로컬(지역) 브랜치 목록 보기$ git branch# 리모트(원격) 브랜치 목록 보기$ git branch -r# 모든 브랜치 목록 보기$ git branch -a# 현재 브랜치에서 새로운 브랜치 생성$ git branch &amp;lt;새로운 브랜치 명&amp;gt;# 브랜치 체크아웃$ git checkout &amp;lt;브랜치명&amp;gt;# 다른 브랜치를 현재 브랜치로 병합$ git merge &amp;lt;브랜치&amp;gt;# 커밋 일부만 가져와서 합치기 e.g. $ git cherry-pick 76ae30ef$ git cherry-pick &amp;lt;커밋해시&amp;gt;# 브랜치 삭제$ git branch -d &amp;lt;삭제할 브랜치명&amp;gt;저장소 관련 명령# 새로운 원격 저장소 추가$ git remote add &amp;lt;저장소명&amp;gt; &amp;lt;저장소 url&amp;gt;# 모든 원격 브랜치 목록 보기$ git branch -r# 병합 없이 원격저장소의 변경사항을 로컬 브랜치로 가져오기# 직접 병합 작업을 해야함, &amp;lt;저장소명&amp;gt;은 보통 orgin$ git fetch [&amp;lt;저장소명&amp;gt; &amp;lt;브랜치명&amp;gt;]# 자동 병합작업을 거쳐 로컬 브랜치와 합침# git feth + git merge와 같음$ git pull [&amp;lt;저장소명&amp;gt; &amp;lt;브랜치명&amp;gt;]# 원격 저장소의 브랜치에 변경사항 반영$ git push &amp;lt;저장소명&amp;gt; &amp;lt;브랜치명&amp;gt;참고 자료Reference마무리저는 Git을 쓸 때 과거엔 깃크라켄을 쓰긴 했지만 요즘은 IDE에 포함되는 확장이나 기능을 사용하면서 추가로 콘솔 명령을 사용하는 것이 더 좋더라구요.깃 활용은 귀찮지만서도 꼭 해야 하는 작업이죠… 🥲앞으로도 좋은 개발자가 되기 위해 귀찮아도 제 양식이 된다 생각하고 시간을 투자하려고 합니다." }, { "title": "Git mirror, 원격저장소에 미러링 하는 법", "url": "/posts/Git-mirror-%EB%B0%A9%EB%B2%95/", "categories": "개발, Git", "tags": "깃, Git, 도구, 깃허브, 미러링, 깃랩, 복사", "date": "2023-04-24 23:15:00 +0900", "snippet": "다른 깃저장소에 기존 저장소를 옮기고 싶을 때항상 깃허브를 쓰고 싶지만 마음대로 될리가..간혹가다 깃랩에서 깃허브로 리포지토리를 옮기고 싶거나 깃허브에서 다른 리포지토리로 기존 리포지토리를 옮기고 싶을 때가 있다.그럴 때 적용 가능한 팁 💡 이동할 저장소에는 아무것도 생성을 안한 상태로 진행해 주세요.원본 저장소 이력 복사git clone --mirror [원본 저장소 주소]디렉토리 이동cd [원본 저장소 이름].git이동할 원격 저장소 경로 지정git remote set-url --push origin [이동할 저장소 주소]Pushgit push --mirror완료!" }, { "title": "백준 줄 세우기 파이썬(Python) 풀이", "url": "/posts/%EB%B0%B1%EC%A4%80-%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0/", "categories": "알고리즘, 백준", "tags": "알고리즘, 줄, 세우기, 파이썬, Python, 위상정렬, 위상", "date": "2023-04-24 10:42:00 +0900", "snippet": "문제 백준 줄 세우기 난이도: Gold3 https://www.acmicpc.net/problem/2252풀이 알고리즘: 위상 정렬이 문제를 풀이한 과정과 접근법을 공유함니다. N명의 학생을 줄 세우려는데 일부 학생의 순서만 알고 있다면 이것은 위상 정렬로 풀 수 있는 문제다. 위상 정렬은 중간 연결 순서가 정해진 순서를 정렬할 때 효과적인데 이 문제는 마침 일부만 순서가 정해져 있다. graph를 통해 순서를 입력 받고 진입차수를 초기화한다. 진입 차수가 0인 것들을 큐에 넣고 진입차수가 새롭게 0이 되면 다음 큐의 끝에 넣는다. 큐가 아예 빌 때까지 순회한다. 순회하면서 출력하면 그것이 정답이다.import sysinput = sys.stdin.readlinen, m = map(int, input().split())# 위상 정렬로 문제를 풀 수 있어 보인다.graph = [[] for _ in range(n+1)]indegree = [0] * (n+1)for _ in range(m): a, b = map(int, input().split()) graph[a].append(b) indegree[b] += 1# 진입 차수가 0인 것들을 큐에 넣는다.q = []for i in range(1, n+1): if indegree[i] == 0: q.append(i)while q: next_q = [] for now in q: print(now, end=&#39; &#39;) for i in graph[now]: indegree[i] -= 1 if indegree[i] == 0: next_q.append(i) q = next_q후담필자는 예전에 위상정렬로 풀면 안되는 카카오 코딩테스트의 양과 늑대가 나왔던 문제를 위상정렬로 풀었었다.위상정렬을 알지도 못할 때 적용해서 풀어보려고 했다가 코딩테스트에서 낭패를 본 적이 있었는데 위상정렬이란걸 제대로 알게 되고 어떨 때 이와 같이 접근해야 하는지 확실히 알아가자." }, { "title": "Jekyll, Html 캐시 비활성화 방법 cache-busting", "url": "/posts/Jekyll-Blog-%EC%BA%90%EC%8B%9C%EB%B2%84%EC%8A%A4%ED%8C%85/", "categories": "개발, 블로그", "tags": "Jekyll, 캐시, 캐시중지, 캐시비활성화, 자동삭제, 캐시삭제, 예찬군", "date": "2023-04-23 15:32:00 +0900", "snippet": "지킬 블로그 대공감.. 레이아웃을 수정했는데 갱신이 안돼!분명 레이아웃을 수정했는데 왜 안되지… 웨.. 웨? (냐옹)Github를 이용해 Jekyll 블로그를 하다보면 레이아웃과 같은 화면을 분명 바꿨음에도 갱신이 되지 않는 경우가 있다.그것은 바로 웹캐시(Web cache)로 인해 발생하는 문제인데 브라우저가 사이트의 탐색을 빠르게 하기 위해 브라우저 내부에 html, js, css 등의 자산들을 기록하고 재방문시 이를 가져오는 방식을 택하기 때문이다.본론부터 말하면 어느정도 해결할 방법들이 있다. 여러 해결법 중에 택해서 사용하자.메타 태그 활용으로 해결 (캐시 사용 자체를 비활성화)자주 갱신되는 목적의 블로그에선 캐시를 사용하지 않기 위해 다음과 같은 방법을 적용하는 것도 괜찮은 방법이다.&amp;lt;!-- 다음 코드를 html 헤더에 삽입--&amp;gt;&amp;lt;!--no-cache : 캐시 사용 전 재검증을 위한 요청을 강제no-store : 클라이언트의 요청, 서버의 응답 등을 저장 안함must-revalidate : 캐시 사용 전 반드시 만료된 것인지 검사(http 1.1에서 적용됨)--&amp;gt;&amp;lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot;/&amp;gt;&amp;lt;!--특정시간 이후엔 리소스가 만료됐음을 의미. 0, -1 등은 즉시 만료Ex) Expires: Wed, 21 Oct 2015 07:28:00 GMT--&amp;gt;&amp;lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&amp;gt;&amp;lt;!-- 위의 명시된 날짜 이후가 되면 페이지가 캐싱되지 않는다.(1990년 이후 쭉) --&amp;gt;&amp;lt;meta http-equiv=&quot;Expires&quot; content=&quot;Mon, 06 Jan 1990 00:00:01 GMT&quot; /&amp;gt;&amp;lt;!-- 페이지 로드시마다 페이지를 캐싱하지 않는다.(HTTP 1.0) --&amp;gt;&amp;lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&amp;gt;빌드 버전(Build version) 사용브라우저는 파일명을 기반으로 캐시를 저장한다. 따라서 js, css 등 html에 삽입되어 사용되는 에셋에 캐싱을 이용하지 않으려면 파일명을 달라지게 해주어야 한다.Github Pages 를 이용해서 Jekyll 사이트를 빌드할 경우Ruby와 Liquid 템플릿 언어가 적용된 Jekyll에서 활용 가능하다. (이게 보통 기본 사양임)_include/ 위치에 build_versions.html이란 파일을 만들어보자.&amp;lt;!-- build_versions.html --&amp;gt;{%- if site.github.build_revision and jekyll.environment == &quot;production&quot; -%} {%- assign build_version = site.github.build_revision -%}{%- else -%} {%- assign build_version = site.time | date: &#39;%s&#39; -%}{%- endif -%}그리고 이를 다른 header 문구가 있는 html 파일에 다음과 같이 적용한다.{% include build_versions.html %}&amp;lt;!-- 각종 css --&amp;gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;{{ &#39;assets/css/style.css&#39; | relative_url }}?v={{ build_version }}&quot;/&amp;gt;&amp;lt;!-- 각종 js --&amp;gt;&amp;lt;script src=&quot;{{ &#39;assets/js/bundle.js&#39; | relative_url }}?v={{ build_version }}&quot;&amp;gt;&amp;lt;/script&amp;gt;Github Actions로 Jekyll 사이트를 빌드할 경우만약 깃허브 Actions로 빌드할 경우 기본적으로 Ubuntu 환경에서 빌드되며 jekyll의 환경에선 기본적으로 site.time에 build된 시간이 저장된다.&amp;lt;link href=&quot;{{ &#39;assets/js/core.min.js&#39; | relative_url }}?v={{ site.time | date: &#39;%s&#39; }}&quot; rel=&quot;stylesheet&quot;/&amp;gt;이처럼 에셋을 가져오는 문구의 href 마지막에 ?v={{ site.time | date: &#39;%s&#39; }} 를 붙이면 된다.%s는 기본적으로 date의 strftime 필터를 가져오며 1970-01-01 00:00:00 UTC. 이후로 지난 초 형식으로 변환한다. 이제부터 잘 갱신되는 블로그와 행복한 나날을 보내자!참조https://stalker5217.github.io/javascript/cache/https://milanaryal.com.np/jekyll-static-assets-cache-busting/" }, { "title": "백준 랜선 자르기 풀이, 파이썬", "url": "/posts/%EB%B0%B1%EC%A4%80-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0-%ED%92%80%EC%9D%B4,-%ED%8C%8C%EC%9D%B4%EC%8D%AC/", "categories": "알고리즘, 백준", "tags": "니체, 예찬군, 알고리즘, 랜선, 자르기, 파이썬, Python", "date": "2023-04-22 23:52:00 +0900", "snippet": "문제 출처 https://www.acmicpc.net/problem/1654풀이 과정 이 문제는 이분탐색으로 풀 수 있다. N개보다 많이 잘라내는 값을 찾아야 하는데 더 이상 N개보다 더 많이 자를 수 있게 되면 start를 +1 시킨다. 1씩 늘어나므로 end와 같아지게 되면 그것이 최대 길이가 된다. 시간복잡도는 KlogN인데 N보다 많이 만들어도 되는 경우가 있기 때문에 근소한 차이가 있다.import sysK, N = map(int, sys.stdin.readline().split())lan = [int(sys.stdin.readline()) for _ in range(K)]start = 1end = max(lan)while start &amp;lt;= end: mid = (start + end) // 2 cnt = 0 for l in lan: cnt += l // mid if cnt &amp;gt;= N: start = mid + 1 else: end = mid - 1print(end)" }, { "title": "WebSocket 챕터 #2: 웹소켓 프로토콜", "url": "/posts/WebSocket-%EC%B1%95%ED%84%B0-2-%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/", "categories": "개발, 네트워크", "tags": "니체, 예찬군, WebSocket, socket, 웹소켓, 네트워크, 프로토콜, protocol", "date": "2023-04-21 20:03:00 +0900", "snippet": "웹소켓 프로토콜 (WebSocket Protocol)WebSocket wire protocol (RFC 6455) HyBi 워킹 그룹에서 개발 상위 구성 요소 (2가지) 연결 매개변수를 협상하는 데 사용되는 오프닝 HTTP 핸드셰이크 메커니즘 텍스트 및 바이너리 데이터의 낮은 오버헤드, 메시지 기반 전송을 가능하게 하는 바이너리 메시지 프레임 메커니즘 웹소켓 프로토콜은 기존 양방향 HTTP 기술의 목표를 해결하려고 시도하며, 따라서 HTTP 포트 80 및 443에서 작동하도록 설계되었습니다.하지만 웹소켓은 HTTP로 제한하지 않습니다. 때문에 전용 포트 사용하기도 가능하고 더 간단한 핸드셰이크를 사용할 수도 있습니다.WebSocket Protocol, RFC 6455웹소켓 프로토콜은 브라우저 외부에서 사용할 수 있는 독립형 프로토콜입니다.이진 프레이밍 레이어 (Binary Framing Layer) 발신자 임의의 UTF-8 또는 바이너리 페이로드를 제공합니다. 수신자 전체 메시지를 사용할 수 있을 때 알림 받습니다. 이를 위해 WebSocket은 사용자 지정 바이너리 프레임 형식(참조 1)을 사용애플리케이션 메시지를 하나 이상의 프레임으로 분할하고, 이를 대상으로 전송하고, 재조립한 후 전체 메시지가 수신되면 수신자에게 최종적으로 알립니다.웹소켓 통신은 이와 같은 프레임들을 교환하며 이루어집니다.참조 1. WebSocket의 어플리케이션 메시지 프레임 구조Frame (프레임)가변 길이의 프레임 헤더와 메시지를 일부나 전부 전달할 수 있는 페이로드를 포함하는 가장 작은 통신 단위.Message (메시지)논리적 애플리케이션 메시지에 매핑되는 프레임들을 합친 것어플리케이션 메시지 프레이밍 메시지가 쪼개져서 프레임 단위가 되는 것을 의미함 애플리케이션 메시지를 여러 프레임으로 분할할지 여부 클라이언트 및 서버 프레이밍 코드의 기본 구현에 의해 결정 +) 여기서 말하는 프레이밍은 MTU와 같은 것으로 쪼개지는 프레이밍이 아님https://theamiableapi.com/2012/04/01/message-framing-in-rest/ 애플리케이션은 개별 웹소켓 프레임이나 프레이밍이 수행되는 방식을 알지 못함 하지만 각 웹소켓 프레임이 와이어에서 어떻게 표현되는지 주요 내용을 이해하는 것은 여전히 유용 각 프레임의 첫번째 비트(FIN) = 메시지 최종조각 여부 메시지는 단 하나의 프레임으로 구성될 수 있음 Opcode(4비트) = 전송된 프레임의 유형, 제어프레임 애플리케이션 데이터 전송을 위한 텍스트(1) 바이너리(2) 연결 상태 확인을 위한 연결 닫기(8) 핑(9) 퐁(10) 마스크 비트 페이로드의 마스크 여부를 나타냄 마스크란 보안 기술로 개인을 식별할 수 있는 데이터를 보이지 않게 처리하는 것 여기서 페이로드 마스킹은 특히 웹소켓 프로토콜에서 중간자 공격(Man-in-the-Middle Attack)을 방지하기 위해 탄생함 https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_servers 위 글과 같이 손쉽게 마스킹된 페이로드를 디코딩 가능하지함 페이로드 마스킹의 목적 데이터 패킷의 패턴을 숨기고 위해 있음 프록시 서버와 같은 중간자가 트래픽을 분석하고 패턴을 찾는 것을 막기 위함임. (연산비용이 높음) 기본적인 방어책임, 데이터 보안 수준을 높이기 위한 완벽한 해결책 x 클라이언트에서 서버로 전송되는 메시지에만 해당 페이로드 길이 (마스크 비트를 빼고 7비트로 표시, 또한 가변 길이 필드로 표시) 0-125면 페이로드 길이를 뜻함 126이면 다음 2바이트가 프레임 길이를 나타내는 16비트 부호 없는 정수 127이면 다음 8바이트가 프레임 길이를 나타내는 64비트 부호 없는 정수 즉 7bit의 페이로드 길이 값에 따라 그림 1의 Extended length를 얼마나 쓸지를 정함 마스킹 키 페이로드를 마스킹하는 데 사용되는 32비트 값이 포함 모든 클라이언트에서 페이로드가 마스킹 되는 것은 캐시 포이즈닝 공격(cache poisoning attack)을 방지할 수 있음. 공격에 대한 자세한 내용은 W2SP 2011에서 발표된 “Talking to Yourself for Fun and Profit”를 참조하세요.해당 내용이 난해하다면 이 블로그의 게시글도 확인해보세요. 페이로드 연결이 설정될 때 클라이언트와 서버가 확장자를 협상한 경우 애플리케이션 데이터와 사용자 지정 확장자 데이터가 포함 결과적으로 각 웹소켓 프레임에는 2~10바이트의 프레임 오버헤드가 발생.클라이언트는 웬만하면 항상 마스킹 키를 전송해야 하고 헤더에 4바이트가 추가되어 6~14바이트의 오버헤드가 발생.이 오버헤드들은 모두 트래픽과 대역폭 제한에 영향을 줌 WebSocket Multiplexing과 Head-of-Line Blocking메시지는 하나 이상의 프레임으로 분할될 수 있기 때문에 웹소켓은 head-of-line blocking에 취약.HTTP/2 프레이밍 메커니즘에 “stream ID”에 해당하는 것이 없기 때문에 서로 다른 메시지의 프레임은 인터리빙(끼워넣기) 안됨 (Streams, Messages, and Frames 참조)대용량 메시지는 여러 개의 웹소켓 프레임으로 분할되어 있더라도 다른 메시지와 관련된 프레임의 전송을 차단합니다.-&amp;gt; 애플리케이션이 지연 시간에 민감한 데이터를 전송하는 경우 주의 필요. 메시지 분할 등을 활용HyBi 워킹 그룹에서 개발한 새로운 “웹소켓용 멀티플렉싱 확장” 이 확장 기능을 사용하면 하나의 TCP 연결이 채널 ID로 태그된 프레임을 캡슐화하여 여러 개의 가상 웹소켓 연결을 제공할 수 있습니다… 멀티플렉싱 확장 기능은 별도의 논리 채널을 유지하며, 각 채널은 별도의 핸드셰이크 헤더를 포함하여 독립적인 웹소켓 연결과 논리적으로 완전히 동등한 기능을 제공합니다.WebSocket Multiplexing (Draft 10)이 확장 기능(HTTP/1 용)을 사용하면 동일한 TCP 연결을 통해 여러 웹소켓 연결(채널)을 멀티플렉싱할 수 있음.HTTP/2는 스트림 멀티플렉싱이 내장되어 있고 HTTP/2 프레이밍 메커니즘 내에서 웹소켓 프레임을 캡슐화하여 단일 세션 내에서 여러 개의 웹소켓 연결을 전송할 수 있습니다.HTTP/2에서의 WebSocket은 RFC 8441에 정의되어 있습니다.결론: HTTP/2가 웹소켓 사양에서 고려할 것이 적다. 프로토콜 확장 (Protocol Extension) WebSocket은 프로토콜 확장을 허용함 연결 포맷과 의미는 새로운 연산 코드와 데이터 필드로 확장 가능. 클라이언트와 서버가 애플리케이션 코드 없이 기본 웹소켓 프레이밍 계층 위에 추가 기능 구현 가능 클라이언트는 초기 업그레이드 핸드셰이크에서 확장 활성 여부를 알리고 서버는 협상된 연결의 수명 동안 사용할 확장을 선택하고 승인해야 함대신 웹소켓에서 헤더 필드나 페이로드에 대한 기타 정보와 같은 다른 메타데이터는 사용할 수 없습니다.WebSocket 프로코콜 확장의 예(By HyBi Working Group) A Multiplexing Extension for WebSockets 별도의 논리적 웹소켓 연결이 기본 전송 연결을 공유할 수 있는 방법 제공. 각 웹소켓 연결에는 전용 TCP 연결이 필요하므로 비효율적이기에 이 확장은 각 웹소켓 프레임에 “channel ID”를 추가하여 여러 가상 웹소켓 채널이 단일 TCP 연결을 공유해 해결합니다. Compression Extensions for WebSocket 웹소켓 프로토콜에 압축 기능을 추가하는 웹소켓 확장을 만들기 위한 프레임워크 과거에 기본 웹소켓 사양은 전송된 데이터의 압축을 위한 메커니즘이나 조항을 제공하지 않았을 때 제공되었던 확장입니다. 각 프레임은 애플리케이션에서 제공하는 페이로드 데이터를 전달합니다. 바이트 전송에서 압축 기술이 적용되지 않아 전송 오버헤드가 발생했고 압축 확장은 HTTP에서 제공하는 전송-인코딩 협상과 비슷합니다. 웹소켓 멀티플렉싱과 RFC 7692HTTP/2 가 도입되면서 대부분의 브라우저가 웹소켓 멀티플렉싱을 지원합니다.이 글의 원본이 적혔던 2013년에서 2년이 지난 2015년 12월 RFC 7692가 제정되어 WebSocket 프로토콜의 압축 통신에 대한 사양이 기술되었습니다.프레임별 압축은 페이로드 콘텐츠를 프레임 단위로 압축하므로 여러 프리엠으로 분할될 수 있는 대용량 메시지에는 적합하지 않습니다. 따라서 RFC 7692에선 메시지별 압축을 적용하는 방식에 대해 기술하고 있으며 Deflate 알고리즘을 이용한 압축을 설명하고 있습니다.현재 다양한 websocket 라이브러리들이 이를 지원하고 있고 이를 활성화 하면 웹소켓으로 발생하는 트래픽의 80% 가량을 절감할 수 있다고 한 라이브러리에서 설명하고 있습니다.HTTP 업그레이드 협상(HTTP Upgrade Negotiation)WebSocket protocol 메시지 지향 통신 자체 바이너리 프레이밍 계층 하위 프로토콜 협상 선택적 프로토콜 확장웹소켓 프로토콜은 위와 같은 강력한 기능을 제공합니다.하지만 메시지를 교환하기 전에 클라이언트와 서버는 연결을 설정하기 위해 적절한 매개변수로 협상해야 합니다.HTTP를 활용하여 Handshake(핸드셰이크, 협상 과정)를 수행하면 아래와 같은 이점이 있습니다.(처음에 얘기했듯 웹소켓은 HTTP 프로토콜에 한정되지 않습니다) 기존 HTTP 인프라 호환 웹소켓 서버는 클라이언트(브라우저)에서 유일하게 열려 있는 포트인 80번과 443번 포트에서 실행할 수 있습니다. 협상을 수행하기 위해 커스텀 웹소켓 헤더를 사용하여 HTTP Upgrade 플로우를 재사용하고 확장할 수 있습니다. 아래는 협상을 위해 HTTP Upgrade 플로우에서 사용하는 매개변수들입니다.Sec-WebSocket-Version클라이언트가 사용하려는 웹소켓 프로토콜의 버전(RFC6455의 경우 “13”)을 나타냄.서버가 이 버전을 지원하지 않으면 지원되는 버전 목록과 함께 응답.Sec-WebSocket-Key클라이언트가 전송하는 자동 생성 키.서버가 요청된 버전의 프로토콜을 지원한다는 것을 증명하기 위해 서버에 호환성 검증 요청.Sec-WebSocket-AcceptSec-WebSocket-Key의 서명된 값을 포함함.요청된 프로토콜 버전을 이해하고 있음을 증명하는 서버 응답임.Sec-WebSocket-Protocol애플리케이션 하위 프로토콜을 협상하는 데 사용.클라이언트는 지원되는 프로토콜 목록을 알리고 서버는 단일 프로토콜 이름으로 응답함.Sec-WebSocket-Extensions웹소켓 확장을 사용할지 여부를 협상할 때 사용클라이언트는 지원되는 확장을 알리고 서버는 동일한 헤더를 반환하여 사용할 리스트를 확인함.HTTP을 웹소켓으로 업그레이드 하는 클라이언트 요청GET /socket HTTP/1.1Host: server.example.comConnection: Upgrade #1Upgrade: websocket #2Sec-WebSocket-Key: eGsdHGKsxBFSzDBe23djsS== #3Sec-WebSocket-Protocol: chat, multichat #4Sec-WebSocket-Version: 13 #5Sec-WebSocket-Extensions: x-custom-extension1, x-custom-extension1 #6Origin: http://example.com 서버에 다른 프로토콜로 변경 요청 웹소켓 프로토콜로 업그레이드 요청 서버 프로토콜 지원 확인을 위한 자동 생성 키 애플리케이션에서 지정한 하위 프로토콜의 선택적 목록 클라이언트에서 사용하는 웹소켓 프로토콜 버전 클라이언트가 지원하는 프로토콜 확장 목록(선택 사항)(위는 순서대로 적용되는 것이 아닙니다)웹소켓 요청에는 same-origin 정책이 적용됩니다.브라우저는 upgrade 핸드셰이크에 origin 헤더를 추가하고 원격 서버는 CORS를 사용해 요청을 수락하거나 거부할 수 있습니다(Cross-Origin Resource Sharing (CORS) 참조).서버저가 클라이언트에 웹소켓으로 전환 됐음을 알리는 응답HTTP/1.1 101 Switching Protocols #1Connection: Upgrade #2Upgrade: websocket #3Access-Control-Allow-Origin: http://example.com #4Sec-WebSocket-Accept: eFdPsjqiIjqh73FJAlzEsd=AKao= #5Sec-WebSocket-Protocol: multichat #6Sec-WebSocket-Extensions: x-custom-extension1 #7 웹소켓 업그레이드를 확인하는 101 응답 코드 클라이언트에 연결이 다른 프로토콜로 변경됨을 알림 웹소켓 프로토콜로 업그레이드 요청 교차 출처 연결에 대한 옵트인(opt-in)을 나타내는 CORS 헤더 서명된 키 값 증명 프로토콜 지원 서버가 선택한 애플리케이션 하위 프로토콜 서버가 선택한 웹소켓 확장 목록(없을 수 있음)모든 RFC6455 기반 웹소켓 서버는 동일한 방식으로 클라이언트의 호환성 검증 요청에 응답을 생성합니다. 서버는 Sec-WebSocket-Key 값을 표준에서 명시된 고유 GUID 문자열과 결합하여 SHA1 해시를 계산하고, 그 결과를 Base-64로 인코딩하여 클라이언트에 반환합니다.웹소켓 핸드셰이크를 성공적으로 수행하려면, 최소한 프로토콜 버전과 클라이언트가 전송한 자동 생성된 호환성 검증 값이 포함되어야 합니다.또한, 선택한 프로토콜 버전을 확인하기 위해, 서버는 해시된 챌린지-응답이 포함된 101 HTTP 응답 코드를 전송해야 합니다.핸드셰이크가 정상적으로 완료되면, 연결이 WebSocket 메시지 전송을 위한 양방향 통신 채널로 사용될 수 있습니다. 이 시점부터는 HTTP 프로토콜 대신 WebSocket 프로토콜이 사용됩니다.요청 및 응답 스트리밍웹소켓은 동일한 TCP 연결을 통해 양방향 통신을 허용하는 사양에 정의된 유일한 프로토콜입니다.참조2는 여러 통신 전송 방식이 어떤 구조와 방향으로 통신하는지에 대한 시각화입니다.참조 2. XHR과 SSE, WebSocket의 연결 플로우 XHR은 요청-응답(request-response) 통신의 ‘트랜잭션’에 최적화되어 있습니다.클라이언트는 서버에 완전한 HTTP 요청을 전달하고, 서버는 완전한 형식의 응답으로 응답합니다. 요청 스트리밍은 지원되지 않으며, 스트림 API가 도입되기 전에는 신뢰할 수 있는 브라우저 간 응답 스트리밍 API도 존재하지 않았습니다. XMLHttpRequest, fetch API, Axios와 같은 방식들이 REST API 요청에 사용되며, 이들은 모두 polling 방식의 요청 구조를 구현할 수 있습니다. SSE를 사용하면 텍스트 기반 데이터의 효율적이고 지연 시간이 짧은 서버 간 스트리밍이 가능합니다.클라이언트가 SSE 연결을 시작하고 서버는 이벤트 소스 프로토콜을 사용하여 업데이트를 클라이언트로 스트리밍합니다.클라이언트는 초기 핸드셰이크 이후에는 서버에 어떠한 데이터도 전송할 수 없습니다. 웹소켓은 클라이언트와 서버 간의 양방향 통신을 가능하게 하는 프로토콜입니다.앞서 말했듯 텍스트와 바이너리 데이터를 실시간으로 송수신할 수 있습니다.웹소켓은 초기 핸드셰이크를 통해 연결이 수립되며, 이후에는 지속적인 연결을 통해 데이터를 주고받습니다. 그 결과, 웹소켓은 빠른 데이터 교환과 낮은 지연 시간을 제공하며, 서버와 클라이언트 간의 상호 작용이 필요한 실시간 애플리케이션에 적합합니다. 하지만 위 모두 전파 속도와 서버의 큐 대기시간에 종속적인 부분이 있습니다.메시지 오버헤드웹소켓으로 통신하는 메시지에는 오버헤드가 발생합니다.애플리케이션 메시지 하나 이상의 프레임으로 분할. 각 프레임은 2바이트에서 14바이트의 오버헤드를 추가. 프레임은 사용자 정의 바이너리 형식을 통해 이루어지기 때문에 UTF-8 및 바이너리 애플리케이션 데이터 모두 동일한 메커니즘을 통해 효율적으로 인코딩 됨.WebScoket과 XHR 및 SSE와 비교 구분 웹소켓 (WebSocket) XHR (XMLHttpRequest) SSE (Server-Sent Events) 통신 방식 양방향 단방향 (요청-응답) 단방향 (서버 → 클라이언트) 메시지 형식 텍스트, 바이너리 텍스트, 바이너리 텍스트 프레임 구조 간결한 바이너리 프레임 풀 HTTP 헤더 풀 HTTP 헤더 지연 시간 낮음 중간 중간 연결 상태 지속적 각 요청마다 연결 지속적 전송 방식 스트리밍 요청-응답 기반 스트리밍 오버헤드 최소 2바이트 ~ 최대 14바이트 헤더 크기 (일반적으로 500바이트 ~ 2KB), 요청별 연결 헤더 크기 (일반적으로 500바이트 ~ 2KB), 텍스트 전송만 가능 상세 정보 헤더 크기 최소화, 지속적 연결 헤더 크기에 따른 높은 오버헤드, 요청별 연결 헤더 크기에 따른 중간 오버헤드, 이벤트 기반 이 오버헤드에는 애플리케이션 프로토콜에 관계없이 메시지당 60~100바이트의 오버헤드를 추가하는 IP, TCP, TLS 프레이밍의 오버헤드가 포함되어 있지 않습니다. (Optimize TLS Record Size 참조)웹소켓, XHR, SSE의 데이터 효율성 및 압축 비교웹소켓 (WebSocket)웹소켓은 클라이언트와 서버 간의 양방향 통신을 효율적으로 처리하기 위해 설계되었습니다. 웹소켓의 데이터 효율성은 다음과 같은 방식으로 달성됩니다. 간결한 프레이밍: 웹소켓은 간결한 바이너리 프레이밍을 사용하여 메시지를 전송합니다. 이를 통해 웹소켓은 적은 양의 오버헤드로 메시지를 전송할 수 있습니다. 지속적인 연결: 웹소켓은 클라이언트와 서버 간에 지속적인 연결을 유지하므로, 새로운 요청 및 응답을 위한 연결 생성 및 해제 비용이 절약됩니다.웹소켓은 ‘permessage-deflate’라는 확장을 사용하여 데이터 압축을 지원합니다. 이 확장을 사용하면 클라이언트와 서버는 압축된 데이터를 서로 주고받을 수 있습니다. 이를 통해 전송되는 데이터의 크기를 줄이고 대역폭을 절약할 수 있습니다.XHR (XMLHttpRequest)XHR은 요청-응답 통신 방식으로, 헤더를 전송하고 연결을 생성 및 해제하는 비용이 발생합니다. 이러한 특성 때문에 웹소켓에 비해 데이터 효율성이 떨어질 수 있습니다.그러나 압축 측면에서는 XHR이 웹소켓과 유사한 성능을 제공합니다. XHR에서 전송되는 데이터는 HTTP 프로토콜에 의해 압축될 수 있습니다. 대표적인 HTTP 압축 방식으로는 gzip, deflate, brotli 등이 있습니다.SSE (Server-Sent Events)SSE는 서버에서 클라이언트로의 단방향 통신을 지원하며, 헤더 크기에 따른 오버헤드가 있습니다. SSE는 텍스트 기반 데이터 전송에 최적화되어 있으며, 연속적인 데이터 스트림에 적합합니다.SSE에서 전송되는 데이터도 HTTP 프로토콜에 의해 압축될 수 있습니다. 따라서 XHR과 마찬가지로 SSE에서도 압축을 통해 데이터 크기를 줄이고 대역폭을 절약할 수 있습니다. SSE에서도 gzip, deflate, brotli 등의 HTTP 압축 방식을 사용할 수 있습니다. 결론 각 통신 방식의 데이터 효율성 및 압축 성능은 사용 사례에 따라 선택할 수 있으며, 각 방식의 장점을 최대한 활용해야 합니다. 웹소켓은 지속적인 양방향 통신이 필요한 경우, XHR은 트랜잭션 요청-응답 통신이 필요한 경우, SSE는 서버에서 클라이언트로의 지속적인 데이터 전송이 필요한 경우에 적합합니다.커스텀 애플리케이션 프로토콜(Custom Application Protocol)WebSocket은 기존의 HTTP 프로토콜과는 다른 양식을 가지며, 클라이언트와 서버 간에 사용자 지정된 프로토콜을 사용하여 데이터를 전송합니다. 이러한 이유로 WebSocket은 일종의 맞춤형 프로토콜로 간주되기도 합니다.일반적으로, 스트리밍 서비스에서 WebSocket과 같은 프로토콜을 사용하면, 클라이언트와 서버 간에 실시간 양방향 통신을 제공할 수 있습니다. 이를 통해 더 높은 대역폭 사용률과 더 낮은 지연 시간을 제공할 수 있습니다. 또한, 맞춤형 프로토콜을 사용하면 데이터를 압축하거나, 메시지 전달을 최적화하거나, 세션 상태를 관리하는 등의 추가 기능을 구현할 수 있습니다.그러나 WebRTC와 RTMP와 같은 다른 프로토콜도 사용될 수 있습니다. WebRTC는 실시간 비디오 및 오디오 통신을 위해 설계되었으며, P2P 통신 기술을 사용합니다. RTMP는 Adobe Flash 플레이어에서 사용되는 프로토콜로, 동영상 스트리밍에 사용됩니다.브라우저는 HTTP 프로토콜에 최적화되어 있어서, XHR 요청과 같은 HTTP 기반의 요청에 대해서는 다양한 서비스를 제공합니다. 이러한 서비스에는 인증, 캐싱, 압축 등이 포함됩니다.그러나 맞춤형 프로토콜을 사용하면 HTTP 프로토콜에서 제공되는 일부 서비스를 사용할 수 없다는 단점이 있습니다. 예를 들어, HTTP 캐시, 인증, 쿠키와 같은 서비스는 맞춤형 프로토콜에서 직접 구현해야 합니다. 웹소켓에서는 쿠키를 이용해서 초기의 핸드셰이크 연결 구성에서 사용자 인증을 진행할 수 있습니다.WebSocket과 캐시 활용법웹소켓은 CDN 등에서 캐시를 하지 못합니다. 하지만 일반 HTTP 통신은 캐싱이 됩니다.효율적인 캐싱 전략을 위해 웹소켓은 제어 명령을 통신하고 이 제어 명령으로 캐시된 데이터를 불러오게 요청하는 방법을 사용할 수 있습니다.웹소켓 인프라 배포 및 최적화 구성전략웹소켓은 실시간 양방향 통신을 가능하게 하는 효과적인 기술입니다. 웹소켓 인프라 배포를 성공적으로 수행하려면 몇 가지 주요 사항을 고려해야 합니다. 이 글에서는 웹소켓 인프라 배포를 최적화하고 구성하는 방법에 대해 설명합니다. 내부 네트워크 조정내부 네트워크의 라우터, 로드 밸런서, 프록시를 적절하게 구성하고 조정해야 웹소켓 세션의 수명이 길어질 수 있습니다. 이를 통해 오래 지속되는 연결을 지원하고 성능을 개선할 수 있습니다. 외부 네트워크 프록시 고려외부 네트워크의 투명한 및 명시적인 프록시를 고려해야 합니다. 이를 해결하기 위해 TLS를 사용하여 웹소켓 트래픽을 안전하게 터널링할 수 있습니다. 이 방법은 중간 프록시를 우회할 수 있으며, 웹소켓 세션 협상의 성공률을 높이고 연결 시간 초과 간격을 연장하는 데 도움이 됩니다. 클라이언트 네트워크 고려클라이언트 네트워크의 라우터, 방화벽, 프록시를 고려해야 합니다. 일부 네트워크에서는 웹소켓 트래픽을 완전히 차단할 수 있으므로 대체 전략을 갖추는 것이 중요합니다. 인프라 검토 및 사용자 지정 구성인프라를 검토하고 필요한 경우 사용자 지정 구성을 적용해야 합니다. 예를 들어, Nginx 또는 HAProxy와 같은 서버, 프록시, 부하 분산 장치의 구성을 조정하여 오래 지속되는 연결을 지원할 수 있습니다.예를 들어, Nginx 를 이용한 구성을 보여드리겠습니다. 이 예제에서는 다음과 같은 구성 요소를 사용합니다. 업스트림 서버 정의 (Upstream Server Definition) 로드 밸런싱 알고리즘 (Load Balancing Algorithm) 프록시 설정 (Proxy Configuration)먼저 Nginx 설정 파일 (예: /etc/nginx/nginx.conf)에서 업스트림 서버를 정의합니다.http { upstream websocket_servers { server backend1.example.com:8080; server backend2.example.com:8080; } ...}이 코드는 “websocket_servers”라는 이름의 업스트림 서버 그룹을 정의하며, 백엔드 서버 두 개를 포함합니다.다음으로 로드 밸런싱 알고리즘을 선택합니다. Nginx에서 사용할 수 있는 로드 밸런싱 알고리즘 중 하나는 라운드 로빈입니다. 이 알고리즘은 기본적으로 사용되며, 추가 구성 없이 사용할 수 있습니다. 다른 알고리즘을 사용하려면 아래와 같이 설정합니다.upstream websocket_servers { least_conn; # 최소 연결 알고리즘을 사용하려면 이 코드를 추가 ip_hash; # 세션 지속성을 위한 IP 해시 알고리즘을 사용하려면 이 코드를 추가 server backend1.example.com:8080; server backend2.example.com:8080;}마지막으로 프록시 설정을 수행합니다. Nginx에서 웹소켓을 프록시하려면 HTTP/1.1 버전을 사용하고 필요한 헤더를 설정해야 합니다. 또한 타임아웃 값을 늘려 안정적인 연결을 보장할 수 있습니다.server { listen 80; server_name example.com; location /websocket { proxy_pass http://websocket_servers; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_read_timeout 3600s; proxy_send_timeout 3600s; }}이 코드는 웹소켓 요청을 “websocket_servers” 업스트림 그룹으로 전달하도록 프록시 설정을 합니다. HTTP/1.1을 사용하고 “Upgrade” 및 “Connection” 헤더를 설정하여 웹소켓 핸드셰이크를 지원합니다. 마지막으로, 읽기 및 전송 타임아웃을 1시간 (3600초)으로 설정하여 오랫동안 연결이 유지되도록 합니다.이 구성은 웹소켓 서비스에 고가용성과 확장성을 제공하며, 요청을 여러 백엔드 서버 간에 균등하게 분산시킵니다.또한 다음과 같은 이점이 있습니다. 고가용성: 한 서버에 문제가 발생하더라도 다른 서버가 요청을 처리하여 서비스가 지속됩니다. 확장성: 백엔드 서버를 추가하거나 제거하여 트래픽 변화에 대응할 수 있습니다. 성능 최적화: 로드 밸런싱 알고리즘을 사용하여 웹소켓 요청을 최적의 서버로 전달할 수 있습니다.물론, 웹소켓 인프라 배포를 위한 Nginx 프록시 및 로드 밸런싱 구성은 여러 가지 다른 요소에 따라 변경될 수 있습니다. 예를 들어, 보안을 강화하기 위해 SSL/TLS 설정을 추가할 수 있으며, 웹 애플리케이션 요구 사항에 맞게 다른 로드 밸런싱 알고리즘을 사용할 수 있습니다.이 예제는 대부분의 인프라에서 오래 지속되는 세션을 처리하기 위해 사용자 지정 구성이 필요한 것을 보여주기 위한 것입니다. 따라서 애플리케이션에서 지속적인 연결을 구현하기 전에 인프라를 검토하는 것이 중요합니다.장기간 지속되는 유휴 세션은 모든 중간 서버에서 메모리와 소켓 리소스를 소모합니다. 이로 인해 보안, 리소스 및 운영 측면에서 짧은 시간 제한을 설정하는 것이 합리적인 경우가 많습니다. 웹소켓, SSE, HTTP/2와 같이 긴 세션을 사용하는 기술을 도입하면 새로운 운영상의 문제가 발생할 수 있습니다.요약하면, 웹소켓 인프라 배포를 최적화하려면 다음과 같은 사항을 고려해야 합니다: 내부 네트워크의 라우터, 로드 밸런서, 프록시를 조정합니다. 외부 네트워크의 프록시를 고려하고 TLS를 사용하여 웹소켓 트래픽을 안전하게 터널링합니다. 클라이언트 네트워크의 라우터, 방화벽, 프록시를 고려하고 대체 전략을 준비합니다. 인프라를 적절하게 검토하고 필요한 경우 사용자 지정 구성을 적용합니다.이렇게 하면 웹소켓 인프라 배포를 효과적으로 관리하고 성능을 최적화할 수 있습니다.웹소켓 서비스 성능 향상을 위한 체크리스트웹소켓 서비스의 성능을 향상시키기 위해 고려해야 할 주요 요소들은 다음과 같습니다: 최신 웹소켓 라이브러리 사용: 보안과 성능 향상을 확보하기 위해 최신 버전의 웹소켓 라이브러리를 사용하세요. 이렇게 하면 기능 개선 및 버그 수정이 반영된 라이브러리를 활용할 수 있습니다. 보안 웹소켓 사용: 중간자 공격으로부터 데이터를 보호하기 위해 TLS를 통한 보안 웹소켓(WSS)을 사용하세요. 서버 성능 최적화: 서버의 메모리, CPU 사용량 및 네트워크 대역폭을 모니터링하고, 필요한 경우 서버 자원을 증가시켜 성능을 향상시키세요. 프로토콜 최적화: 데이터 전송을 최적화하기 위해 사용되는 프로토콜을 검토하고, 필요한 경우 최적의 프로토콜로 전환하세요. 커넥션 재사용: 가능한 경우 웹소켓 커넥션을 재사용하여, 커넥션 설정 및 해제 시 발생하는 오버헤드를 최소화하세요. 메시지 크기 최적화: 데이터를 압축하거나 필요한 데이터만 전송하도록 메시지 구조를 최적화하여 메시지 크기를 최소화하세요. 스트레스 테스트 및 성능 모니터링: 웹소켓 서비스에 대한 스트레스 테스트를 수행하고, 서비스의 성능을 지속적으로 모니터링하여 문제를 신속하게 파악하고 개선하세요. 폴리필 성능 주의: 필요한 경우 폴리필 성능에 주의를 기울여 호환성 문제를 해결하면서 성능 저하를 최소화하세요. 서브프로토콜 협상 활용: 애플리케이션 프로토콜을 결정하기 위해 서브프로토콜 협상을 활용하세요. 이를 통해 클라이언트와 서버 간에 효율적인 통신 방식을 선택할 수 있습니다. 클라이언트에서 버퍼링된 데이터량 모니터링: 클라이언트에서 버퍼링된 데이터량을 모니터링하여 데이터 전송 속도와 서버 측 처리 속도 간의 균형을 유지하세요. 이를 통해 클라이언트의 메모리 사용량을 최적화하고 애플리케이션 성능을 향상시킬 수 있습니다. 대용량 애플리케이션 메시지 분할: 대기열 차단을 피하기 위해 대용량 애플리케이션 메시지를 분할하세요. 이렇게 하면 큰 메시지가 전송되는 동안 다른 메시지들이 대기 상태에 빠지는 것을 방지할 수 있습니다. 이진 페이로드 최적화: 전송 크기를 최소화하기 위해 이진 페이로드를 최적화하세요. 이를 통해 데이터 전송 속도를 높이고, 네트워크 지연을 줄일 수 있습니다. UTF-8 콘텐츠 압축 고려: 전송 크기를 최소화하기 위해 UTF-8 콘텐츠를 압축할 수 있는지 고려하세요. 이를 통해 텍스트 기반의 메시지 전송 효율을 높일 수 있습니다. 받은 이진 페이로드에 적절한 이진 타입 설정: 받은 이진 페이로드에 대해 적절한 이진 타입을 설정하여 데이터 처리 속도를 높이세요.이러한 요소들을 체크리스트로 만들어 성능 향상을 위한 지침으로 활용하면 웹소켓 서비스의 전반적인 성능을 개선할 수 있습니다. 또한 지속적인 모니터링과 최적화를 통해 서비스의 안정성과 확장성을 높일 수 있습니다.또한 모바일 기기의 경우 배터리 최적화 문제를 신경써야할 수 있습니다. 물론 요즘 디바이스들은 충분한 배터리 용량을 가지고 있지만 그럼에도 이러한 고려는 생각해볼만 합니다.다음의 타 저자의 게시글들을 확인해 보세요. Preserve Battery Power Eliminate Periodic and Inefficient Data Transfers Nagle and Efficient Server Push Eliminate Unnecessary Application Keepalives" }, { "title": "WebSocket 챕터 #1: 서론과 웹소켓 API", "url": "/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/", "categories": "개발, 네트워크", "tags": "니체, 예찬군, WebSocket, socket, 웹소켓, 네트워크", "date": "2023-04-17 09:03:00 +0900", "snippet": "웹소켓(WebSocket) 서론WebSocket은 브라우저와 서버 간의 양방향 메시지 전송을 가능하게 하는 프로토콜입니다. 웹소켓은 브라우저에서 사용할 수 있는 가장 효과적이고 유연한 통신 수단 중 하나로, 기존 HTTP 인프라와의 상호 운용성을 제공하며, 메시지 중심 통신 및 효율적인 메시지 프레이밍을 통해 클라이언트와 서버 간에 원활한 데이터 스트리밍이 가능합니다.주요 특징 연결 협상 및 동일 출처 정책 시행 기존 HTTP 인프라와의 상호 운용성 메시지 중심 통신 및 효율적인 메시지 프레이밍 서브프로토콜 협상 및 확장성웹소켓은 간단한 JSON 페이로드부터 사용자 지정 바이너리 메시지 형식까지 클라이언트와 서버 간에 다양한 애플리케이션 프로토콜을 계층화하여 전달할 수 있습니다. 이를 통해 양쪽 모두 언제든지 데이터를 전송할 수 있습니다.그러나 사용자 정의 프로토콜의 단점은 바로 사용자 정의라는 점입니다. 애플리케이션은 브라우저에서 제공하는 상태 관리, 압축, 캐싱 등의 기능을 고려해야 합니다.웹소켓을 사용할 때 항상 설계상의 제약과 성능의 절충점이 존재합니다. 최상의 성능을 위해서는 각 프로토콜과 전송 방식의 강점을 활용하는 것이 중요합니다.결론웹소켓은 HTTP, XHR, 또는 SSE를 완전히 대체할 수는 없습니다. 오히려, 이 프로토콜들의 강점을 활용하여 웹 애플리케이션의 성능과 사용성을 최적화하는 것이 바람직합니다. 웹소켓은 강력한 통신 도구이지만, 제약 사항과 장단점을 고려하여 적절한 사용이 필요합니다.웹소켓은 여러 표준의 집합으로, 웹소켓 API는 W3C에서 정의하고 웹소켓 프로토콜(RFC 6455)와 그 확장은 HyBi 워킹 그룹(IETF)에서 정의합니다.웹소켓 API (WebSocket API)브라우저에서 직접 제공하는 웹소켓 API는 매우 작고 간단합니다. 연결 관리 및 메시지 처리의 모든 하위 수준 세부사항은 브라우저에서 처리 합니다. 웹소켓 리소스의 URI와 애플리케이션 콜백이 필요한데, 아래 예제에서 코드를 확인할 수 있습니다.//1. 새 보안 웹소켓 연결(wss) 열기const ws = new WebSocket(&#39;ws://example.com/socket&#39;);//2. 웹소켓 연결이 설정될 때 호출되는 선택적 콜백ws.onopen = function () { ws.send(&quot;Hello world&quot;); //3. 클라이언트가 서버로 보내는 메시지};//4. 서버에서 새 메시지를 보낼 때마다 호출되는 콜백 함수ws.onmessage = function(msg) { if(msg.data instanceof Blob) { processBlob(msg.data); //5. 수신된 바이너리 메시지 처리 로직 호출 } else { processText(msg.data); //6. 수신된 텍스트 메시지 처리 로직 호출 }};//7. 연결 오류가 발생한 경우 호출되는 선택적 콜백ws.onerror = function (error) { ...};//8. 연결이 종료될 때 호출되는 선택적 콜백ws.onclose = function () { ...};EventSource API와 비슷한 경험을 제공하면서도 웹소켓은 더 다양한 기능을 지원합니다. 이러한 유사성은 웹소켓이 기존 API와 호환성을 유지하면서 확장성을 제공하기 위한 의도적인 설계입니다.하지만 몇 가지 중요한 차이점이 있습니다. 웹소켓은 양방향 통신을 지원하며, 클라이언트와 서버가 서로 메시지를 주고받을 수 있습니다. 반면, EventSource는 서버에서 클라이언트로의 단방향 통신만 지원합니다.그리고 그 과정에서 서로 다른 프로토콜을 사용합니다.(EventSource Protocol 과 WebSocket Protocol) 웹소켓은 텍스트뿐만 아니라 바이너리 데이터도 전송할 수 있습니다. EventSource는 텍스트 데이터만 전송할 수 있습니다. WebSocket은 서브프로토콜을 정의할 수 있습니다. 클라이언트와 서버는 이런 사용자 지정 프로토콜을 사용하여 데이터를 주고받을 수 있습니다. 예를 들어, JSON, XML, 또는 protobuf와 같은 데이터 형식을 사용하여 데이터를 전송할 수 있습니다. 또한, 서브 프로토콜을 사용하면, 각각의 특화된 기능을 구현할 수 있습니다.추가적인 내용은 아래에서 알아보겠습니다.브라우저의 웹소켓 애뮬레이팅 (Emulating WebSocket In The Browser) 웹소켓 프로토콜은 클라이언트와 서버간 실시간 양방향 통신을 위한 프로토콜입니다. 최신 버전(v13)으로 발전해 모든 브라우저에서 지원되며, 브라우저 지원 상황은 http://caniuse.com/websockets에서 확인 가능합니다. 하지만, 일부 브라우저에서는 웹소켓을 지원하지 않는 경우가 있으므로, 이를 대비하여 에뮬레이션하는 라이브러리가 필요합니다. 하지만, 웹소켓 API를 에뮬레이션하는 라이브러리는 전송에 어려움이 있어 성능에 영향을 미치는 경우가 있습니다. 이를 해결하기 위해 SockJS와 같은 라이브러리는 “seamless fallback”을 가능하게 합니다. 이는 브라우저에서 웹소켓을 지원하지 않는 경우, SockJS가 웹소켓 대신 다른 전송 방법을 사용하여 대체합니다. 이를 통해 브라우저 호환성을 보장하면서도 성능 문제를 해결할 수 있습니다. 또한, Socket.IO와 같은 라이브러리는 고급 기능을 추가로 제공합니다. 이러한 라이브러리를 사용하면 실시간 프레임워크를 쉽게 구현할 수 있으며, 구현과 구성을 최적화하여 성능을 향상시킬 수 있습니다. 이러한 라이브러리는 이벤트 기반 프로그래밍 모델을 제공하여 클라이언트와 서버 간의 통신을 단순화하며, 클라이언트 측에서도 간편하게 구현할 수 있습니다. 따라서, 웹소켓을 이용한 실시간 양방향 통신을 구현하려면 브라우저 호환성을 고려하고, 성능 문제를 해결하기 위해 에뮬레이션하는 라이브러리와 고급 기능을 제공하는 라이브러리를 적절히 선택하여 사용해야 합니다.최상의 성능을 얻기 위해 네이티브 웹소켓 인터페이스를 활용하고, 폴백 전송 성능을 최적화하여 전반적인 통신 성능을 향상시키세요. WS와 WSS URL 스키마 (WS and WSS URL Schemes)WebSocket 프로토콜은? 웹소켓 프로토콜은 IETF(Internet Engineering Task Force)의 HyBi Working Group에서 제정되었습니다. 이 그룹은 브라우저와 서버 간 통신에서 발생하는 문제를 해결하고 최적화된 양방향 통신 채널을 구축하기 위해 웹소켓 프로토콜을 만들었습니다. 웹소켓 프로토콜은 브라우저와 서버 간 최적화된 양방향 통신 채널을 구축하기 위해 HTTP 대신 자체 사용자 지정 스키마를 사용합니다.웹소켓 프로토콜의 URL 스키마 일반 텍스트 통신에는 ‘ws’를 사용합니다. 암호화된 채널(TCP+TLS)이 필요한 경우에는 ‘wss’를 사용합니다.웹소켓 프로토콜의 확장성 브라우저 외부에서도 비 HTTP 교환을 통해 협상할 수 있도록 확장성을 제공합니다. 하지만, 사용자 지정 체계에서는 웹소켓 세션을 설정하기 위한 대체 핸드셰이크 메커니즘에 대한 기존 표준이 없어 추가적인 작업이 필요합니다. 정리웹소켓 프로토콜은 브라우저와 서버 간 최적화된 양방향 통신 채널을 제공하며, HTTP 대신 자체 사용자 지정 스키마를 사용합니다. 일반 텍스트 통신에는 ‘ws’를 사용하고, 암호화된 채널이 필요한 경우에는 ‘wss’를 사용합니다. 또한, 웹소켓은 브라우저 외부에서도 비 HTTP 교환을 통해 협상할 수 있도록 확장성을 제공하지만, 사용자 지정 체계에서는 추가적인 작업이 필요합니다.텍스트 및 바이너리 데이터 수신 (Receiving Text and Binary Data By WebSocket)웹소켓을 사용하여 텍스트와 바이너리 데이터를 효율적으로 전송하고 수신할 수 있습니다. 메시지와 애플리케이션 코드 구성 웹소켓은 메시지와 애플리케이션 코드로 구성되어 사용자가 데이터의 버퍼링, 구문 분석 및 재구성에 대해 걱정할 필요가 없습니다. 데이터 처리의 유연성 웹소켓은 텍스트와 바이너리 데이터 모두 처리할 수 있으며, 애플리케이션 페이로드에 대한 제약이나 가정을 두지 않습니다. 페이로드 정보 추적 웹소켓 프로토콜은 메시지에 대한 두 가지 정보만 추적합니다. 페이로드 길이: 가변 길이 필드로서 메시지의 길이를 나타냅니다. 페이로드 유형: UTF-8과 바이너리 전송을 구분하기 위한 정보를 포함합니다. 데이터 자동 변환 및 전달 브라우저가 새 메시지를 수신할 때, 텍스트 기반 데이터는 DOMString 객체로, 바이너리 데이터는 Blob 객체로 자동 변환된 다음 애플리케이션에 전달됩니다. 성능 최적화 옵션 수신된 바이너리 데이터를 Blob 대신 ArrayBuffer로 변환하도록 브라우저에 지시함으로써 데이터 처리를 더욱 효율적으로 수행할 수 있습니다. Blob이란? 변경 불가능한 원시 데이터로 구성된 파일과 같은 객체이며 데이터를 수정할 필요가 없고 더 작은 덩어리로 분할할 필요가 없습니다. 예: 전체 Blob 객체를 이미지 태그에 전달할 수 있는 경우 최적의 형식(XHR로 데이터 다운로드의 예 참조) 반면에 바이너리 데이터에 추가 처리를 수행해야 하는 경우 ArrayBuffer가 더 적합할 수 있습니다. 아래는 성능 최적화 옵션을 사용한 예시입니다.const ws = new WebSocket(&quot;ws://example.com/socket&quot;);// 바이너리 메시지 수신 시 ArrayBuffer 변환 강제 수행ws.binaryType = &quot;arraybuffer&quot;;ws.onmessage = function (msg) { if (msg.data instanceof ArrayBuffer) { processArrayBuffer(msg.data); } else { processText(msg.data); }}; User agents는 이 속성을 수신 바이너리 데이터를 처리하는 방법에 대한 힌트로 사용할 수 있습니다. 속성이 “blob”으로 설정되어 있으면 디스크에 스풀링(데이터를 채우는 것)하는 것이 안전하며, “arraybuffer”로 설정되어 있으면 데이터를 메모리에 보관하는 것이 더 효율적일 가능성이 높습니다.물론 사용자 에이전트는 수신 데이터를 메모리에 보관할지 여부를 결정하기 위해 보다 미묘한 휴리스틱을 사용하도록 권장됩니다.The WebSocket API, W3C Candidate Recommendation자바스크립트를 이용한 웹소켓에서 받은 바이너리 데이터 디코딩 예시로 C로 작성된 구조체의 객체를 메시지로 받아 웹소켓에서 디코딩하는 과정을 설명합니다. 먼저, 다음과 같은 C 스타일의 바이너리 데이터 구조를 고려해봅시다. struct personInfo { char name[20]; unsigned int age; float height;};// 이렇게 할당되어 있다 가정합니다.struct personInfo person = {&quot;John Doe&quot;, 30, 180.5f}; 이 구조체는 사람의 정보를 담고 있습니다. 이름은 20바이트의 문자 배열, 나이는 unsigned int 형식, 그리고 키는 float 형식으로 구성되어 있습니다. 웹소켓에서 이벤트를 받으면 다음과 같이 처리할 수 있습니다. 다음 예시처럼 WebSocket은 브라우저 내에서 바이너리 데이터를 처리하는 데 필요한 도구를 애플리케이션에 제공합니다. websocket.onmessage = function (event) { var buffer = event.data; // TypedArray를 사용한 방식 var nameView = new Uint8Array(buffer, 0, 20); var ageView = new Uint32Array(buffer, 20, 1); var heightView = new Float32Array(buffer, 24, 1); // 출력: Name: John Doe, Age: 30, Height: 180.5 console.log( &quot;Name: &quot; + String.fromCharCode.apply(null, nameView) + &quot;, Age: &quot; + ageView[0] + &quot;, Height: &quot; + heightView[0] ); // DataView를 사용한 방식 var dataView = new DataView(buffer); var name = &quot;&quot;; for (var i = 0; i &amp;lt; 20; i++) { name += String.fromCharCode(dataView.getUint8(i)); } var age = dataView.getUint32(20); var height = dataView.getFloat32(24); // 출력: Name: John Doe, Age: 30, Height: 180.5 console.log(&quot;Name: &quot; + name + &quot;, Age: &quot; + age + &quot;, Height: &quot; + height);}; 위의 예시에서 ArrayBuffer를 각각 TypedArray 방식과 DataView 방식으로 바이너리 데이터를 해독하고 있습니다. WebSocket텍스트 바이너리 데이터 전송 (Sending Text and Binary Data with WebSocket)WebSocket을 사용하면 클라이언트와 서버 간에 텍스트 및 바이너리 데이터를 쉽게 주고받을 수 있습니다. WebSocket 프로토콜은 TCP 연결을 통해 양방향 메시지 전달이 가능하게 합니다. 이를 구현하는 과정은 다음과 같습니다. WebSocket API 사용 데이터WebSocket API는 다음과 같은 데이터 유형을 지원합니다. UTF-8 인코딩된 문자열 바이너리 전송을 위한 ArrayBuffer, ArrayBufferView, Blob 객체 WebSocket 연결 생성 및 데이터 전송웹 애플리케이션에서 이미지 파일과 텍스트 메시지를 동시에 전송해야 한다고 가정해봅시다.이 경우 다음과 같이 WebSocket 연결을 생성하고 데이터를 전송할 수 있습니다. const ws = new WebSocket(&#39;ws://example.com/socket&#39;); ws.onopen = function () { // 텍스트 메시지 전송 ws.send(&quot;Hello!&quot;); // 바이너리 데이터 (예: 이미지 파일) 전송 var buffer = new ArrayBuffer(128); ws.send(buffer); }; ``` send() 메서드 및 비동기 처리send() 메서드는 비동기식으로 처리되며, 데이터는 클라이언트에 의해 큐에 대기됩니다.함수는 즉시 반환되므로 대용량 페이로드 전송 시 전송 완료 신호로 오해하지 않도록 주의해야 합니다. 데이터 양 모니터링애플리케이션에서는 소켓의 bufferedAmount 속성을 사용하여 브라우저에서 대기 중인 데이터 양을 모니터링할 수 있습니다.bufferedAmount가 0인 경우에만 send 메서드를 호출하여 데이터를 전송하는 방식도 있습니다. 이렇게 함으로써, 소켓의 대기열에 너무 많은 데이터가 쌓이는 것을 예방할 수 있습니다. 다음은 만약 시스템에 업데이트가 발생했다면 서버의 데이터 갱신을 bufferedAmount가 0일 때에만 send를 호출하는 간단한 예제 코드입니다. var socket = new WebSocket(&quot;ws://example.com&quot;);var updateInterval = 1000; // 1초마다 시스템 업데이트 체크function checkUpdate() { // 시스템 업데이트 체크 후 업데이트가 있을 경우, 서버에 전송 var updateData = getUpdateData(); // 시스템 업데이트 데이터 가져오기 if (updateData) { socket.send(JSON.stringify(updateData)); // 업데이트 데이터를 JSON 문자열로 변환하여 전송 }}// 일정 주기마다 시스템 업데이트 체크setInterval(function () { checkUpdate();}, updateInterval); 위 예제 코드에서 checkUpdate 함수는 일정 주기마다 시스템 업데이트를 체크합니다. 시스템 업데이트가 있을 경우, 해당 업데이트 데이터를 JSON 형태로 변환한 후, WebSocket을 사용하여 서버에 전송합니다. 시스템은 옵저버 패턴 등을 활용해서 더욱 구조적으로 구성할 수도 있습니다. 이렇게 함으로써, 소켓의 대기열에 데이터가 많이 쌓이는 것을 예방하고 HOL 차단 현상을 완화할 수 있습니다. HOL 차단 현상을 완전히 해결하는 것은 아니지만, HOL 차단 현상을 예방하거나 완화하는데에 도움을 줄 수 있습니다. Head of Line (HOL) 차단 현상 해결전송을 최적화하려면 각 메시지 유형이 소켓에 대기열에 포함되는 방식과 시기에 세심한 주의를 기울여야 합니다. 이를 통해 Head of Line (HOL) 차단 현상을 해결할 수 있습니다. - 메시지 유형별 대기열 사용: 각 메시지 유형에 대한 대기열을 따로 유지하여, 큰 데이터 덩어리가 전송될 때 작은 데이터 덩어리가 먼저 전송되는 현상을 막을 수 있습니다. 예를 들어, 문자열과 바이너리 데이터를 구분하여 따로 전송하는 것이 좋습니다.- 작은 데이터 덩어리 우선 전송: 큰 데이터 덩어리가 전송될 때는 작은 데이터 덩어리를 먼저 전송하는 것이 좋습니다. 이를 위해서는 메시지 크기를 제한하거나, 메시지가 큰 경우에는 여러 개의 작은 데이터 덩어리로 분할하여 전송하는 방법을 사용할 수 있습니다.- 프로토콜 수준에서 해결: WebSocket 프로토콜 자체에서 HOL 차단 현상을 해결하는 기능을 제공할 수 있습니다. 예를 들어, WebSocket 스펙의 중간에 데이터를 전송할 수 있는 형식인 &quot;Continuation Frames&quot;을 사용하는 것이 좋습니다. 이를 이용하면, 큰 데이터 덩어리를 여러 개의 작은 데이터 덩어리로 분할하여 전송할 수 있으며, 이를 받는 쪽에서는 이들을 조합하여 전체 데이터를 복원할 수 있습니다.- bufferedAmount를 확인하면 HOL를 예방하는 것엔 도움이 됩니다. 하지만 위와 같은 방식을 사용해서 근본적으로 HOL의 문제를 해결하는 것이 좋습니다. 많은 애플리케이션은 제어 트래픽과 같은 우선순위가 높은 업데이트와 백그라운드 전송과 같은 우선순위가 낮은 업데이트 등 여러 클래스의 메시지를 생성합니다.전송을 최적화하려면 애플리케이션은 각 메시지 유형이 소켓에 대기열에 포함되는 방식과 시기에 세심한 주의를 기울여야 합니다!서브프로토콜 협상WebSocket 프로토콜 웹소켓 프로토콜은 각 메시지의 형식에 대해 어떠한 가정도 하지 않습니다. 단일 비트는 메시지에 텍스트 또는 바이너리 데이터가 포함되어 있는지 여부를 추적해 클라이언트와 서버가 효율적으로 디코딩할 수 있도록 하지만 그렇지 않은 경우 메시지 내용은 불투명합니다. 각 요청과 응답의 HTTP 헤더를 통해 추가 메타데이터를 전달하는 HTTP 또는 XHR 요청과 달리 웹소켓 메시지에는 이와 동등한 메커니즘이 없습니다. 메시지에 대한 추가 메타데이터가 필요한 경우 클라이언트와 서버가 이런 데이터를 전달하기 위해 자체 서브프로토콜을 구현해야 합니다. 클라이언트와 서버는 고정된 메시지 형식에 미리 합의할 수 있습니다. 예를 들어, 모든 통신은 JSON 인코딩된 메시지 또는 사용자 정의 바이너리 형식을 통해 이루어지며 필요한 메시지 메타데이터는 인코딩된 구조의 일부 형식 사용합니다. 클라이언트와 서버가 서로 다른 데이터 유형을 전송해야 하는 경우 일관된 메시지 헤더를 구성해야 하며, 이를 통해 나머지 페이로드를 디코딩하기 위한 지침을 전달할 수 있습니다. 텍스트 메시지와 바이너리 메시지를 혼합하여 페이로드와 메타데이터 정보를 전달할 수 있습니다. 예를 들어 텍스트 메시지로 HTTP 헤더에 해당하는 내용을 전달한 다음 바이너리 메시지로 애플리케이션 페이로드를 전달할 수 있습니다. 웹소켓은 메시지의 유연성과 낮은 오버헤드를 제공하지만, 메시지 직렬화와 메타데이터 관리는 문제의 일부입니다. 서로 다른 클라이언트와 서버 간에 동기화를 유지하려면 프로토콜 협상이 필요합니다.웹소켓은 서브프로토콜 협상 API를 제공하여 이 문제를 해결합니다. 클라이언트는 초기 연결 핸드셰이크를 통해 어떤 프로토콜을 지원하는지 서버에 알릴 수 있습니다.이를 통해 클라이언트와 서버는 동일한 프로토콜을 사용하고 메시지 형식 및 메타데이터의 구조를 미리 합의할 수 있습니다.const socket = new WebSocket(&quot;ws://example.com/socket&quot;, [ &quot;chat&quot;, &quot;notification&quot;,]);socket.onopen = function () { if (socket.protocol === &quot;chat&quot;) { // 서버와 클라이언트가 합의한 &#39;chat&#39; 서브프로토콜에 따른 로직 수행 } else if (socket.protocol === &quot;notification&quot;) { // 서버와 클라이언트가 합의한 &#39;notification&#39; 서브프로토콜에 따른 로직 수행 }};이 예시에서는 chat과 notification 두 가지 서브프로토콜을 WebSocket 생성자에 전달합니다. 클라이언트는 초기 핸드셰이크 중에 서버에게 이를 알리며, 서버는 클라이언트가 지정한 서브프로토콜 중 하나를 선택하여 응답합니다.하위 프로토콜 협상이 성공하면 클라이언트에서 onopen 콜백이 실행되고 WebSocket 객체의 프로토콜 속성을 통해 선택한 프로토콜을 확인할 수 있습니다. 클라이언트와 서버는 이를 통해 메시지의 형식과 메타데이터 구조를 미리 합의할 수 있습니다.서브프로토콜 이름은 애플리케이션에서 정의되며, 초기 핸드셰이크 중에 클라이언트가 서버에게 전송됩니다. 코어 웹소켓 API에는 서브프로토콜 이름에 대한 특별한 처리 방법이 없으며, 지정된 서브프로토콜은 애플리케이션 로직과 관련된 부분입니다. 선택적으로 onerror를 이용해서 협상에 실패했을 때의 동작을 추가할 수 있습니다.웹소켓 API를 사용하면 쉽게 웹소켓 연결을 관리하고 메시지를 처리할 수 있으며, 높은 유연성과 확장성을 제공합니다. 이를 통해 실시간 웹 애플리케이션 및 서비스에 최적화된 솔루션을 구현할 수 있습니다. 하지만 다음과 같은 유의사항도 있습니다. 웹소켓은 기본적으로 연결 지향형이며, 네트워크 지연이나 연결 손실의 영향을 받을 수 있습니다. 웹소켓은 기본적으로 암호화되지 않음. 따라서 중요한 데이터를 전송할 때는 반드시 보안 웹소켓(wss)를 사용해야 합니다. 웹소켓은 전통적인 HTTP 프로토콜과는 다르게 작동하므로, 프록시 서버나 방화벽 설정에 주의해야 합니다.이러한 문제를 해결하기 위해 기존 인프라와 웹소켓이 함께 작동하도록 구성할 수 있습니다.웹소켓 API는 높은 성능과 실시간 통신 기능을 제공하는 동시에 간단한 인터페이스를 유지합니다. 이를 통해 개발자들은 웹소켓 기반의 다양한 애플리케이션과 서비스를 구축할 수 있으며, 사용자에게 뛰어난 경험을 제공할 수 있습니다. 그러나 이를 사용하기 위해서는 웹소켓의 특성과 제약 사항을 이해하고 적절한 설계 및 구현이 필요합니다.다음에는 이러한 웹소켓 API가 구현되기 위해 정의된 웹소켓 프로토콜에 대해 알아보겠습니다." }, { "title": "프로그래머스 level3 입국심사 파이썬 풀이", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-level3-%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC/", "categories": "알고리즘, 프로그래머스", "tags": "니체, 예찬군, 알고리즘, 프로그래머스, 이분탐색, LEVEL3", "date": "2022-06-26 14:59:00 +0900", "snippet": "문제 설명n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.제한사항 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다. 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다. 심사관은 1명 이상 100,000명 이하입니다.입출력 예 n times return 6 [7, 10] 28 입출력 예 설명가장 첫 두 사람은 바로 심사를 받으러 갑니다.7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.출처 본 문제의 저작권자는 프로그래머스가 아닙니다. 이 문제는 https://codeforces.com/blog/entry/967 의 라이센스에 의하여 공개되었습니다.※ 공지 - 2019년 9월 4일 문제에 새로운 테스트 케이스를 추가하였습니다. 도움을 주신 weaver9651 님께 감사드립니다.#ax1 + (n-a)x2 + ... 가 최소값이 되게 하는 것#수식으론 풀 수 없는 무한 항에 가까운 문제#경사 하강법과 비슷한 방식을 사용할 수 있다. 이분 탐색def solution(n, times): left = 1 #최소 시간 right = times[-1] * n #최악 시간 while left &amp;lt;= right: mid = (left + right) // 2 count = sum(map(lambda x: mid//x, times)) if count &amp;lt; n: left = mid + 1 else: right = mid - 1 return right + 1이분 탐색으로 풀 수 있는 문제였습니다.처음에 이분탐색을 어떻게 적용해야 할지를 몰라 결국 솔루션을 보게된 문제입니다. ㅠㅠ" }, { "title": "안드로이드앱-브래인매니저", "url": "/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%95%B1-%EB%B8%8C%EB%9E%98%EC%9D%B8%EB%A7%A4%EB%8B%88%EC%A0%80/", "categories": "포트폴리오, 메인프로젝트", "tags": "니체, 예찬군, 안드로이드, 앱, SQLite", "date": "2022-03-20 23:03:00 +0900", "snippet": "NeoMindStd/BrainManager 프로젝트깃허브 링크소개사용자가 기억하고자 하는 내용(키워드)을 간격 반복 알고리즘으로 복습시간을 알람. 사용자가 해당 내용을 잊지 않게 하는 안드로이드 앱입니다.기능이 약간 추상적일 수 있는데 간단히 소개하자면 사용자가 키워드를 입력하고 해당 키워드의 설명을 적어넣고 등록하면 그 키워드와 설명에 대한 문제를 알아서 생성해서 복습할 수 있도록 도와줍니다.영어단어, 사람, 기술적인 배움 등등 온갖 외워야 할 것들을 쉽게 외울 수 있도록 도와주는 것입니다!구현을 하면서 가중치를 업데이트 하는 방식의 알고리즘을 사용했는데 문제의 정답률에 따라서 복습을 최적화 하는 등의 기능을 추가로 구현해볼 수 있을 것 같습니다.개발 후기4인 개발 팀이었지만 저와 팀장 둘이서 거의 모든 기능을 구현하기도 하고 여러 버그가 남아 있어 관리적 측면에선 실패한 프로젝트입니다. 하지만 이를 경험하면서 애자일방식 개발과 의사소통의 필요성을 느끼게 되었고 이후 프로젝트들에서 이에서 많은 것들을 피드백하여 개선할 수 있었습니다.요약 내용 인원 4 개발기간 2019.03~2019.06 배포 플레이스토어 링크 성과 플레이스토어 50회 이상 설치 개발환경 범주 스택 언어 개발도구 주요 패키지 실행화면주요 역할설계 아이디어 제안자로서 아키텍처 설계구현 복습 화면 복습 알림 알고리즘(간격 반복 알고리즘) 관계성 설정 푸시 알림 야간모드 SQLite 쿼리 Locale별 언어 처리 안드로이드 버전별 동작 처리애플리케이션 아키텍처" }, { "title": "핑 모니터링 툴 개발", "url": "/posts/%ED%95%91-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%ED%88%B4-%EA%B0%9C%EB%B0%9C/", "categories": "포트폴리오, 서브프로젝트", "tags": "니체, 예찬군, C#, Ping, 핑툴", "date": "2022-03-20 21:43:00 +0900", "snippet": "redniche/Ping-Monitoring 프로젝트깃허브 링크소개인터넷의 특정 네트워크 기기와의 핑테스트를 위해 만들어진 프로그램입니다.인트라넷 상황에서 내부망을 관제해야할 때 사용하고자 진행했습니다. 하지만 결국 핑 모니터링 툴이기 때문에 모든 환경에서 사용할 수 있습니다.Thread를 사용해 여러 ip주소에 핑테스트를 할 수 있게 개발했는데 덕분에 스레드에 대한 이해를 높일 수 있었습니다.다만 공유자원의 교착상태를 막기 위해 Semaphore를 사용했는데 이 당시에만 해도 async await에 대해 제대로 알지 못하는 상태에서 이를 사용해서 제대로 활용하지 못한 점이 아쉬움으로 남아 있습니다.기술스택 범주 스택 언어 프레임워크 개발 환경 Framework: .Net Framework 4.7.1 IDE: Visual Studio 2019(back up) Language: C#사용법지원기능네트워크 모니터링 망이름 (공백 혹은 Tabs) 1.1.1.1(ip형식) 1.1.1.1(ip형식)과 같이 입력 후 Start 버튼 클릭. Start를 누르면 입력창은 전부 *로 변합니다.핑 모니터링 목록은 열과 행으로 구분되는데 줄바꿈으로 열을 추가합니다.핑상태는 라벨의 색으로 구분합니다.초록색: 핑 100 이하주황색: 핑 200 이하빨간색: 핑 200 초과보라색: 연결불가투명도 조절화면의 투명도를 아래의 스크롤바를 이용해 변경할 수 있습니다.IP 노출 방지화면에 표시된 IP 주소는 모두 *로 처리됩니다.모니터링 정지시에는 비밀번호가 필요합니다. ‘예찬3’3번 틀릴시 프로그램 강제 종료됩니다.비밀번호 갱신 기능은 필요시 업데이트 예정입니다." }, { "title": "웹 디자인-헬스가든", "url": "/posts/%EC%9B%B9-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%97%AC%EC%8A%A4%EA%B0%80%EB%93%A0/", "categories": "포트폴리오, 서브프로젝트", "tags": "니체, 예찬군, 웹디자인, Cafe24, 웹호스팅", "date": "2022-03-20 21:43:00 +0900", "snippet": "헬스가든이란?㈜ 바이오앤라이프에서 운영하는 온라인 쇼핑몰입니다.https://blog.naver.com/kwak5336와 같이 홍보용 블로그를 운영하면서 여러 한방제품들을 판매하는 회사입니다.개발 배경제가 학부 4학년 때 교외 국가 근로를 진행하면서 위의 업체에서 근로를 진행했었는데 사장님이 저의 개발 능력으로 홈페이지 재단장을 요청하셔서 진행했습니다.보통 국가 근로를 하면서 이런 일을 하지는 않지만 저는 이것 또한 경험을 넓히고 사회에 공헌하는 기회라 생각하여 잘 만들어 보기 위해 노력했습니다.개요 범주 스택 언어 개발환경 호스팅 결과물사이트 링크: https://health-garden.shop/" }, { "title": "수상기록 모음", "url": "/posts/%EC%88%98%EC%83%81%EA%B8%B0%EB%A1%9D-%EB%AA%A8%EC%9D%8C/", "categories": "포트폴리오, 대외활동", "tags": "니체, 예찬군, 수상기록, 삼성SW아카데미, 아이디어, 공모전", "date": "2022-03-20 18:36:00 +0900", "snippet": "삼성 SW 아카데미 공통 프로젝트 최우수상상장 교부 전수상 요약삼성 청년 소프트웨어 아카데미의 2학기 공통 프로젝트에서Unity 기반의 웹RTC 멀티플레이 게임을 개발해 최우수 팀으로 선정됨.프로젝트 깃https://github.com/redniche/INCRIME개요 인원 5 개발 기간 2022.01.10~ 2022.02.18 개발 환경 요약 UnityNode.js ExpressMySQL 프로젝트 소개 링크   후기 개발을 진행하면서 기술적인 배움 뿐만 아니라 디스코드와 노션을 활용한 정보 공유, 개발 계획 관리, 버그 해결까지 효과적으로 마무리한 프로젝트입니다.이후에 진행하는 프로젝트에서 깃, Jira, 디스코드, 노션 등 여러 도구를 활용한 현업 수준의 프로젝트를 진행하는 것에 도움이 되었습니다.삼성 SW 아카데미 프로젝트 우수상수상 요약삼성 청년 소프트웨어 아카데미에서 1학기 공통 진행 프로젝트인공공데이터를 이용한 HappyHouse 서비스 주제의 프로젝트에서 우수팀으로 선정됨.프로젝트 깃https://github.com/redniche/HappyHouseProject개요 인원 2 개발 기간 2021.11.18 ~ 2021.11.25 개발 환경 요약 Spring BootMySQLVue.js 핵심 기능 Kakao Map, Jsoup 크롤링, 공공데이터 API 후기 일주일의 짧은 기간동안 일정관리, 명세서 기반의 프로젝트 진행, Notion과 Git을 활용한 애자일적인 소프트웨어 개발 등을 경험했습니다.현실에선 항상 시간이 넉넉한 것은 아닐 수 있습니다. 저희는 데드라인이 아주 짧은 프로젝트에서도 유용한 결과물을 만들어내는 역량을 기를 수 있었습니다.삼성 SW 아카데미 1학기 성적우수상수상 요약삼성 청년 소프트웨어 아카데미에서 우수한 성적으로 1학기 교육을 이수함.개요 인원 1 기간 2021.07.07 ~ 2021.11.26 교육 과정 요약 JAVA 알고리즘DBWeb HTML, JavaScript, CSS SPA Framework: Vue.js 후기 삼성 청년 SW 아카데미에 입과하고 상당히 빠르게 시간이 지나갔습니다. 교육 중에 아주 바쁘다는 것을 완전히 체감할 수 있었습니다.저는 게으른 점이 조금 있습니다. 이를 개선하기 위해 삼성의 현업 멘토님들께 질문하고 답변 받은 일정관리 법으로 대략적인 일정을 관리하며 배운 것들을 다시 곱씹는 방식으로 성적을 유지했고 성적 우수상을 받을 수 있었습니다.육군혁신 아이디어 콘테스트 표창수상요약육군혁신 “뿜뿜” 콘테스트에서 창의적인 아이디어, 전투발전소요 제언을 통해 육군에 기여한 공을 인정받아 표창됨.개요 인원 1 기간 2018.06.24 ~ 2021.07.14 공모내용 그리드 컴퓨팅 - 목표: 육군 전술서버의 자산 부족 해결, 24시간 켜져있는 클라이언트 컴퓨터 활용- 내용: 서버 처리를 클라이언트에서 분산 처리하는 기술 제안클라이언트 기반 처리- 목표: 모든 데이터 로직을 서버에서 처리하는 기존 구조 개선- 내용: SSR 방식의 클라이언트를 CSR로 전환 제안 후기 당시 서버 운용 시 문제가 되는 구조를 지적하고 클라이언트 처리를 늘리는 방향의 제안서를 작성했습니다.또한 그리드 컴퓨팅에 대한 논문들을 읽고 해당 기술들의 순차적 도입과 방향을 제안하며 참고문헌으로 활용하여 제안을 뒷받침했습니다.여단장 분들 앞에서 발표를 진행했는데 발표를 할 때 어떻게 청중의 수준에 맞출 수 있을지 고민을 하면서 시각적인 자료를 준비했고 발표를 만족스럽게 진행할 수 있었습니다." }, { "title": "신경망 숫자 인식기", "url": "/posts/%EC%8B%A0%EA%B2%BD%EB%A7%9D-%EC%88%AB%EC%9E%90-%EC%9D%B8%EC%8B%9D%EA%B8%B0/", "categories": "포트폴리오, 서브프로젝트", "tags": "니체, 예찬군, C#, 신경망, 다층퍼셉트론, 숫자인식기, MNIST", "date": "2022-03-14 23:23:00 +0900", "snippet": "redniche/Neural-Number-Recognition 프로젝트깃허브 링크소개정사각형 데이터패턴으로 이루어진 숫자를 인식하는 다층 퍼셉트론 기반 신경망입니다. 숫자가 아니어도 패턴을 유추해낼 수 있습니다.학습과 질의를 위해 MNIST 데이터셋을 사용하는 것을 추천합니다.대학생 때 알파고가 이세돌을 이기는 것을 보고 AI 기술이 벌써 이만큼 발전했나 느끼곤 어떻게 저런 것을 만들 수 있을지 연구하는겸 군대에서부터 전역하고 제작하게 되었습니다.MNIST 데이터셋 60000개를 학습하고MNIST 데이터셋 10000개의 테스트 데이터에 대해 대략 97%의 정확도를 보입니다.프로젝트 진행기간 2016년 10월~12월, 2018년 11월기술스택Build Environment Framework: .Net Framework 4.7.1 IDE: Visual Studio 2019 Language: C#데이터셋 MNIST in CSV 링크의 train set, test set 같은 형식의 csv 파일 파일명이 정답인 이미지 파일(.png, .jpg, .jpeg 형식) 예시) 1.png, 2.jpg 주요 사용법Help도움말을 보여줍니다.Create신경망을 생성합니다.본 예제에서는 은닉층이 200노드고 출력이 10개(숫자 수)인 이미지(가로세로 28px)를 인식할 수 있는 신경망 객체를 생성합니다.ShowStatus신경망의 상태를 확인합니다. 대략적인 신경망 객체의 정보를 볼 수 있습니다.CsvTraincsv파일로 신경망을 학습시킬 수 있습니다.예시 학습용 csv파일: 링크CsvQuery학습된 신경망 객체를 csv파일로 테스팅할 수 있습니다.csv파일로 신경망에 질의하는 명령입니다.대용량 테스팅을 할 때 활용할 수 있으며 쿼리의 세부 결과는 로그로 남습니다.예시 테스팅용 csv파일: 링크ImageQuery학습된 신경망 객체를 이미지 파일로 테스팅할 수 있습니다.png, jpg, jpeg 파일을 지원합니다. 여러 파일을 한 번에 테스팅 할 수 있습니다.쿼리의 결과가 콘솔창에 그대로 나타납니다.Save신경망 객체를 저장할 수 있습니다.Open저장된 신경망 객체를 로드합니다.예제 테스트 데이터에 대해 대략 97%의 정확도를 보여주는 신경망 객체 파일을 제공합니다.신경망 객체 파일.neu과거 코드제 블로그입니다.블로그 링크" }, { "title": "고교 창원대학교 연계 악보인식 R&amp;E 프로젝트", "url": "/posts/%EA%B3%A0%EA%B5%90-%EC%B0%BD%EC%9B%90%EB%8C%80%ED%95%99%EA%B5%90-%EC%95%85%EB%B3%B4%EC%9D%B8%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/", "categories": "포트폴리오, 서브프로젝트", "tags": "니체, 예찬군, C, OpenCV, 창원대학교, 영상인식기술, 악보인식", "date": "2022-03-09 17:54:00 +0900", "snippet": "프로젝트 기술스택 개발 IDE 언어 활용 라이브러리 고등학교제가 2012년 3월부터 2015년 2월까지 3년간 신세를 진 고등학교입니다. 진해에 있는 고등학교인데 진짜 열심히 가르칩니다. 진고다만 같이 입학한 학생들이 이미 서로 친한 경우(중학교-고등학교 같은 지역)가 많기 때문에 타지 학생들은 조금 불편할 수 있습니다 ㅜㅜ 저는 타지에서 입학해 적응에 조금 어려움을 겪고 좋은 일도 나쁜 일도 많았지만 다 소중한 추억으로 남았던 곳이기도 합니다R&amp;amp;E(과학영재 창의연구)를 어떻게 하게 되었는가?2013년에 특이하게 고등학교에서 창원대 영재교육원과 MOU(업무협약: 기사링크)를 맺고 창원대학교와 R&amp;amp;E를 진행하기 시작했는데 이 때 컴퓨터공학부와 연계가 되길래 관심있는 학생들을 대상으로 인원들을 모집했던 경험이 있습니다. 결과는 당시 2학년인 나와 1학년 후배 3명이 팀으로 참가하게 되었습니다.R&amp;amp;E 주제 선정 배경결과적으로 우리는 ‘악보 인식 프로그램’을 제작하는 주제를 선정했습니다.이를 선정한 이유에 대해 당시 결과 보고서를 인용해보자면 현재에 경향에 맞춰 사람들이 유행을 따르게 되어 소외된 분야들도 많이 있다. 우리는 그러한 것들을 조금이나마 해결해 보고자 이번 R&amp;amp;E를 구성하게 되었다. 좀 더 나은 미래를 위해 우리가 걸어야하는 길이 무엇인지, 작은 팀이 얼마나 많은 성과를 낼 수 있는지 알고 싶었다. 근래에 컴퓨터 기술이 발달하며 악보영상을 자동으로 인식하고 연주해 주는 악보 인식(Music score Recognition) 시스템에 관한 연구가 많이 진행되었다. 대부분의 연구들이 상당한 성과를 얻어내었고 높은 가치를 가지고 있다. 하지만 최근 들어 이 시스템에 관한 연구가 드물어지고 있으며 진행이 매우 더디어지고 있다. 악보 자동 인식에 대한 연구는 1960년대 후반부터 시작되었으나, 악보의 복잡성과 다양성으로 인하여 아직까지 모든 형태의 악보를 인식할 수 있는 일반적인 악보 인식 시스템은 존재하고 있지 않으며, 기존의 악보 인식 방법들은 인식 속도가 느리고 인식률이 낮은 단점이 있다.라고 기록되어 있습니다. 정보를 더하자면 당시 고등학생 1, 2학년인 우리들은 컴퓨터 과학에 대해 배경지식이 적었고 할 수 있는 것들 또한 매우 적었습니다.따라서 당시 정성환 지도교수 님에게 C언어에 대한 기초적인 교육을 받았고 배종욱 박사 님이 OpenCV로 연구를 진행하고 있던 영상 인식 기술에서 영감을 받아 이 주제를 선정하게 되었습니다.R&amp;amp;E 활동 내용C, OpenCV 학습당시 지도교수 님에게 교육받았던 내용 중 일부입니다. C언어의 기초 문법, 포인터, 파일 입출력에 대해 교육받았습니다.이후에는 배종욱 박사 님에게 우리의 주제를 위한 OpenCV 교육을 받았는데 대표적으로 아래와 같이 교육받고 실험(실습?)해보며 R&amp;amp;E를 진행했습니다. OpenCV라이브러리를 통해 태극기 출력 OpenCV로 웹캠 연결 및 웹캠을 통한 얼굴 인식 (배종욱 박사님입니다 ㅎㅎ) 악보인식 프로그램 제작 과정주제를 위해 교육받은 내용을 바탕으로 개발을 시작했습니다.당시에 대학교의 실습용 컴퓨터에서만 작업을 했었는데 이제와서 찾아보니 아쉽게도 코드 작업물들이 남지를 않아 아쉬움이 있네요…프로젝트를 위해 다음의 3가지를 처음 기획했고 구현했습니다. 넘버 기능 구현 1 컴퓨터 비전 기술을 이용한 악보에서의 음표 추출 O 2 사람의 눈 대신 카메라를 이용하여 악보영상을 처리 X 3 자동음악 연주 시스템 개발을 위한 기반 △ 음표 추출 시스템 구성도 악보의 전처리 및 잡음제거 악보의 원할한 인식을 위해 원본 이미지에서 이진 영상으로 변환, 모폴로지(팽창-&amp;gt;축소)를 이용해 전처리 잡음이란 검출하고자 하는 것 이외의 모든 것을 말합니다악보영상에서의 잡음으로는 조표, 음자리표, 제목, 가사, 코드, 마디 등 존재 레이블링: 인접한 화소에 번호를 매겨 하나의 그룹으로 만드는 작업레이블링을 통해 일정 크기(넓이)보다 작은 그룹을 제거하여 잡음을 제거 했습니다. 기울어짐 보정 기울어짐을 보정하기 위해서 조금 테크니컬한 방식이 필요했는데 직선을 검출하기 위해서 잡음이 제거된 이진 영상에서 모폴로지를 한 번 더 진행해서 오선을 제거하고 이를 비트 연산을 통해 음표부분만 제거된 화면을 얻었어야 했습니다. 그 후 허프 변환을 활용해 직선의 기울기를 검출 했습니다.그 결과로 우리는 위와 같이 기울기가 보정된 화면을 얻을 수 있었습니다. 오선 인식 및 제거 오선 인식을 해야 이를 제거하고 음표의 위치를 알고 어떤 음표인지 알 수 있기 때문에 오선 인식이 필요했습니다.오선 인식은 OpenCV의 히스토그램를 반환받을 수 있는 calcHist() 함수를 활용해서 진행했습니다. 위와 같이 영상의 가로 방향 픽셀값을 모두 더해 히스토그램을 출력하고 피크값을 찾아내 이를 오선의 수직 좌표로 활용했습니다. 결과적으로 이와 같이 각 줄별로 5개의 수직 좌표를 반환받을 수 있었고 이를 이용해 상하 픽셀값 유무를 체크하여 영역 색을 255로 변환했습니다. 음표 추출 음표가 어떤 것인지 어떤 음표인지 인식하기 위한 음표 추출이 필요 했습니다.음표 추출은 다음의 순서로 진행되었습니다. i. 비음표 제거ii. 잇단음표 분리iii. 음표의 추출 i. 비음표 제거 우선 비음표를 위와 같은 방식으로 제거했습니다.상기의 잡음 제거에서 했던 방식처럼 레이블링을 수행하고 비음표의 경우엔 자주 나오지 않기 때문에 그룹의 픽셀 값의 평균을 구한 뒤 편차치가 큰 것들을 제거하는 방식으로 제거할 수 있었습니다. ii. 잇단음표 분리 현재까지 레이블링은 잇단음표를 하나로 인식합니다. 따라서 이를 분리하기 위해 히스토그램을 한 번 더 사용했습니다. 위와 같이 이미지에서 세로 방향의 히스토그램을 그래프에서 앞 뒤 값으 130% 이상 검출 객체 높이의 60% 이상인 수치를 기준으로 Local Maxima(국부 최대값)를 추출해냈습니다. 여기까지 저희는 프로젝트를 진행했고 이후엔 이 실험과 프로젝트의 결과물로 3 종류의 음악 장르에 각각 10곡을 사용해 테스트를 진행해 보았습니다. 테스트동요 옥수수 하모니카 2. 나무를 심자 3. 보물찾기 4. 다람쥐 5. 졸업식 노래 고기잡이 7. 기찻길 옆 8. 꼬부랑 할머니 9. 바닷가에서 반짝반짝 작은 별찬송가 만복의 근원 하나님 2. 이 천지간 만물들아 3. 거룩하신 하나님 다 감사드리세 5. 복의 근원 강림하사 6. 즐겁게 안식한 날 이 날은 주의 정하신 8. 우리의 주여 9. 오 만세 반석이신 저 해와 달과 별들이발라드 다 줄꺼야 2. 벌써 일년 3. 사랑이 지나가면 4. 오래 전 그날 사랑 빛 6.1 다행이다 7. 다행이다(회전) 8. 너에게로 또 다시 보고싶다 10. 너를 위해프로젝트 회고본 연구는 컴퓨터 비전 기술을 이용해 악보 영상 처리를 연구했습니다.연구과정에서 악보의 인식까지 연구를 진행했고 당시 3가지 장르의 30곡의 임의의 악보에 대하여 약 85.2%의 인식률을 보였습니다.찬송가와 같이 화질이 좋은 경우 약 93% 이상의 인식률을 보였습니다.당시 사회 트렌드에서 조금 벗어난 주제이지만 이러한 기술 또한 발전되어야 전체 사회가 발전할 수 있다고 배종욱 박사님이 말씀해 주셨습니다.덕분에 배종욱 박사 님의 영상처리 논문 관련에서도 도움이 되었다?고 하셨었습니다ㅋㅋ여담으로본 프로젝트를 위해 고등학교 2학년 학업과 동시에 창원대학에 왔다 갔다 하는 시간을 쏟으니 내신 성적이 나빠진 부작용이 있었습니다.하지만 처음으로 C언어가 어떤 것인지, 컴퓨터의 구조가 어떤 것인지 프로그래밍을 제대로 어떻게 하는지 배울 수 있었던 시간이었고 지금와서 이런 경험이 없었다면 제가 이때까지 프로그래밍에 열의를 가지고 계속 살아오지 못했을 것이란 생각이 남습니다.포스트 코멘트정말 과거의 기록을 이제와서 정리해보자니 참 이런저런 생각이 많이 남습니다.특히 프로젝트가 끝나고 난 뒤에 보고서와 발표자료를 준비했었는데이 때 3학년이 되어 학교에서 무언가 시키는 것이 많아 끝까지 함께하지 못한 것이 아쉬웠습니다.최종 결과물은 후배들이 아주 열심히 만들어 주었다고 후일담으로 들었습니다.프로젝트 결과물 파일창원대 R&amp;amp;E 악보인식 프로젝트 최종.pptx감사합니다." }, { "title": "Git 커밋 기록 유지하고 옮기기", "url": "/posts/git-%EC%BB%A4%EB%B0%8B-%EA%B8%B0%EB%A1%9D-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B3%A0-%EC%98%AE%EA%B8%B0%EA%B8%B0/", "categories": "개발, Git", "tags": "니체, 예찬군, 깃, Git, 도구, 깃허브, 깃랩, 커밋, 옮기기, 기록, 기록유지", "date": "2022-03-04 16:22:00 +0900", "snippet": "GitHub, GitLab 등 서로 옮기기도 가능일반적인 옮기기 Bare 클론git clone --bare 해당깃링크cd 클론된 깃 폴더 옮길 리포지토리에 푸시git push --mirror 옮길 리포지토리 깃 링크100MB 이상의 파일이 존재할경우 (Git LFS Storage 사용. 비과금시 1GB제한) https://git-lfs.github.com/ 와 https://rtyley.github.io/bfg-repo-cleaner/ 사이트에 들어가서 다운로드 하기. 복사하고자 하는 저장소(gitlab)의 clone을 생성합니다.git clone --mirror 해당깃링크cd 클론된 깃 폴더 커밋 히스토리 내에서 large file을 찾아 트랙킹 합니다. “*.{zip,jar,mp4}” 중괄호 내의 파일은 트래킹을 할 파일 확장자 목록입니다.(이 확장자가 아닌 파일이 100mb를 넘으면 추가 작성)git filter-branch --tree-filter &#39;git lfs track &quot;*.{zip,jar,mp4}&quot;&#39; -- --all BFG를 이용하여 해당 파일들을 git lfs로 변경합니다. (bfg-1.14.0.jar 파일 다운로드 한 경로 지정.)bfg-1.14.0.jar 사용이 잦을 것 같은 경우 고급시스템설정의 환경변수로 이 경로를 등록하면 편합니다.java -jar [경로]bfg-1.14.0.jar --convert-to-git-lfs &#39;*.zip&#39;java -jar [경로]bfg-1.14.0.jar --convert-to-git-lfs &#39;*.jar&#39;java -jar [경로]bfg-1.14.0.jar --convert-to-git-lfs &#39;*.mp4&#39; 새로운 저장소(github)로 mirror-push를 진행합니다.git push --mirror 옮길 리포지토리 깃 링크위와 같이 BFG와 LFS를 이용해서 깃허브를 옮기려면 깃 LFS 스토리지가 사용되며 이는 깃허브를 기준으론 용량제한 정책에 제한을 받습니다(무료기준 1GB). 모든 커밋내역에서 100MB가 넘는 파일의 변경사항을 추적하기 때문에 파일 표기 용량보다 많이 사용될 수 있습니다.따라서 다음과 같이 하는 방법도 추천드립니다.(100mb 이상의 파일이 히스토리에서 삭제됨)100MB이상 히스토리 모두 삭제 후 옮기기 git bash를 엽니다. 복사하고자 하는 저장소(gitlab)의 bare clone을 생성합니다.git clone --bare 해당깃링크cd 클론된 깃 폴더 ( 100MB 에러가 날 경우 ) 기존 Commit에서 100MB보다 큰 파일의 로그를 강제로 없애줘야 합니다.java -jar [경로]bfg-1.14.0.jar --strip-blobs-bigger-than 100M 새로운 저장소(github)로 mirror-push를 진행합니다.git push --mirror 옮길 리포지토리 깃 링크" }, { "title": "좋은 개발자가 되기 위한 방법론", "url": "/posts/%EC%A2%8B%EC%9D%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EB%B0%A9%EB%B2%95%EB%A1%A0/", "categories": "개발, 방법론", "tags": "니체, 예찬군, 좋은개발자, 좋은개발자방법론, 방법론, 해외, 취업", "date": "2022-03-04 15:54:00 +0900", "snippet": "익명의 시니어 분이 제공해주셨습니다목차1 - 문제 해결 방법 3가지 실용적으로 문제 해결하기 공용코드 만들기 코드의 생김새 다듬기 사용자를 위한 코드 짜기 도구를 만들고 개선하기 자동화 하기 질 좋은 문서 남기기 관계 쌓기 동료 사이 신뢰 쌓기 멘토 멘티 찾기 커뮤니티 활동으로 인맥 &amp;amp; 선택의 폭 넓히기 해외 취업 팁실용적으로 문제 해결하기💡 &quot;A 기능을 만들려고 하는데 참고할 만한 프로젝트가 있나요?&quot;&quot;B와 비슷한 기능을 하는 코드가 있나요?&quot;→ 공용코드 만들기 Don’t Repeat Yourself ‘지금 내가 겪는 문제는 동료도 똑같이 겪었다’ 모듈화 오픈소스 활동💡 “기존 코드에 기능을 추가하려는데 너무 걸려요”“버그를 고쳐야하는데 코드를 이해수가 없어요”→ 코드의 생김새 다듬기 “Programs must be written for people to read, and only incidentally for machines to execute”- SICP - 함수 짧게 만들기 변수 이름 잘 짓기 예외 상황 처리아래 두 코드를 서로 비교해보세요func doSomething() { let blah = ... for item in items ( print (item.name) }}var myData: [String: Data]private func somethingElse() -&amp;gt; String { return &quot;Hello World&quot;}func justDoIt() {// whatever..}var myData: [String: Data]func doSomething() { let blah = for item in items { print(item.name) }}func justDoIt() { // whatever..}private func somethingElse() -&amp;gt; String { return &quot;Hello World&quot;}💡 “앱이 / 웹사이트가 사용하기 너무 어려워요””A 기능과 B 기능 중 뭐가 더 나은지 모르겠어요”→ 사용자를 위한 코드 짜기 내가 만든걸 쓸 사람의 입장이 되어보기 백오피스, 플랫폼, 프론트엔드 등 다른 사용자 특성 사이드 프로젝트 출시해보기 사용자와 접점이 있는 모든 곳에 주목도구를 만들고 개선하기💡 “반복 작업에 시간을 너무 많이 낭비해요&quot;“매일/매주/매달 반복되는 작업이 너무 지루해요”→ 자동화 하기 소프트웨어 배포 단계 지속적 통합 / 지속적 배포💡 “테스트용 계정을 만들어야 하는데 어떻게 하나요?&quot;“이렇게 결정하게 된 근거가 뭔가요? 미팅에서 어떤 논의가 오고 갔나요?”→ 질 좋은 문서 남기기 사내 시스템 사용법 회의록, Action Items 코드 아키텍처 정보, 노하우 축적관계 쌓기💡 “A를 새롭게 도입하고 싶은데 동료들을 어떻게 설득해야 하나요?&quot;“B가 더 좋은 방법/기술 인거 같은데 선임은 C를 하자고 해요&quot;→ 동료 사이 신뢰 쌓기 절대적으로 우세한 기술이란건 거의 없다 진심으로 동료의 성장과 행복에 신경 쓰기 팀워크💡 “더 성장하고 싶은데 어떻게 해야할까요?&quot;“개발을 더 잘하고 싶어요&quot;→ 멘토 &amp;amp; 멘티 찾기 가까운 곳에서 시작해서 먼 곳으로 탐색 원격근무의 시대: 온라인 멘토 누군가의 멘토 되기💡 “이직을 하고 싶어요&quot;“개발자가 저 혼자라 외롭고 재미가 없어요”→ 커뮤니티 활동으로 인맥 &amp;amp; 선택의 폭 넓히기 소모임 / 컨퍼런스 발표 Google Developer Expert 내부 추천채용(referral) 관심사, 의견 공유해외 취업 팁지역/국가 선택, 정보 많이 수집(1) 그 나라에서의 삶은 어떨까?나랑 잘 맞을까?(2) 외국인에게 가장 중요한것: 비자(신분)싱가폴: Employment Pass미국: Visa (H-1B, E2, L, O-1 등)경력 쌓기 및 회사 지원(1) 경력이 많을수록 유리하나 극복초년생부터 링크드인 관리(2) 내부 직원 추천으로 지원" }, { "title": "블록체인 [이더리움을 통해 맛보기] (4)", "url": "/posts/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A7%9B%EB%B3%B4%EA%B8%B0-4/", "categories": "블록체인, 정보, 맛보기", "tags": "니체, 예찬군, 개발, 이더리움, 블록체인, 트랜잭션, Remix, IDE, 체인링크,, Chainlink", "date": "2022-02-27 19:34:00 +0900", "snippet": "좀 더 어려운 스마트 컨트랙 직접 만들어보기 (feat. Chainlink)지난 포스트에서 스마트 컨트랙을 Solidity로 작성하는 방법을 배웠습니다.그렇다면 이번엔 좀 더 구체적인 기능들이 있는 스마트 컨트랙을 작성하는 것을 해보도록 하겠습니다.우선 앞으로 이 포스트 및 이외의 여러 스마트컨트랙 작성을 위해 꼭 필요한 배경지식을 잠깐 설명하겠습니다.Solidity의 기능 추가 설명난수스마트컨트랙트에서 여러 서비스(게임, 추첨 등)를 제공하기 위해 난수가 필요한 경우들이 있습니다.하지만 블록체인 상에서 난수를 발생시키는 것은 여러 위험성과 고려사항이 있습니다. 난수를 생성하는 방법 2가지 keccak256 사용 위 방법은 일반적으로 초심자들이 스마트컨트랙에서 난수를 발생시키기 위해 사용하는 방식입니다.다만 이 방식은 근본적으로 완전한 난수가 아니라 “의사 난수”이므로 외부에서 이를 예측하거나 조작하여 많은 피해가 발생한 사례들이 많습니다. Chainlink VRF 솔루션 사용 위의 keccak256을 이용한 난수에서 발생하는 문제들을 해결하기 위해 이더리움 Layer2 솔루션인 Chainlink를 이용하는 방법입니다.이는 탈중앙화된 클라이언트들을 통해 완전히 예측 불가능한 난수를 반환하는 솔루션을 제공합니다.다만 이를 사용하기 위해선 Chainlink의 모듈을 Solidity 내에 포함해야하며 이 솔루션의 난수를 반환받는 함수를 호출하기 위해 LINK라는 토큰이 추가적으로 필요합니다. 난수의 생성엔 여러 방법들이 있겠으나 대표적인 두 방법을 확인해 보았습니다.우리는 이제 난수를 생성하고 활용하는 함수를 포함한 스마트 컨트랙을 만들어서 솔리디티를 배워봅시다근데 이렇게까지 억지로 기능을 넣어야만 했냐…?기부금을 모으는 스마트컨트랙 만들어보기 요구사항 (토글) FundRaising 개발환경 : Remix IDE 기능 설명 일회성으로 동작하는 모금 컨트랙트 일정기간 동안만 이더를 지불하여 모금에 참여할 수 있음 모금 현재 모금액 확인 모금액 수령 기능 랜덤한 기부자의 주소와 기부금을 반환 (의사 난수 사용) 난수 값 요청 (Chainlink VRF 사용) 난수 값 수신 시 이로 랜덤한 기부자의 주소와 기부금을 이벤트로 반환 (Chainlink VRF 사용) 소스 파일 레이아웃 파일 생성 (FundRaising.sol) 라이선스 명시 version pragma 명시 import 선언 (체인링크 관련) contract 선언 생성자 선언 contract가 배포될 때 호출되는 특수 함수 생성자 매개변수 추가 및 상태 변수에 저장 체인링크 VRF를 사용하기 위한 기본 매개변수 추가 address vrfCoordinator, address link, bytes32 keyHash, uint256 fee 사용 VRFConsumerBase(vrfCoordinator, link) 활용 컨트랙트 배포 시 모금 기간과 모금액 수령자를 지정하도록 변경 uint duration - 몇 초 동안 모금이 유효한지 의미 (3600 = 1시간) 정수형 연산자 ‘+’ 현재 타임 스탬프 + duration을 fundRasingCloses의 값으로 지정 block.timestamp - 현재 블록의 유닉스 타임스탬프 값 상태 변수 추가 최소 모금액 지정 기준 : 0.01ether 이더리움 기본 단위 wei 10^18wei = 1ether 1e16==0.01 ether == 10**16 단위 wei, ether등 ** : 지수 연산자 종료 시점 지정 모금 받을 주소 지정 Chainlink VRF를 사용하기 위한 s_keyHash 지정 Chainlink VRF를 사용하기 위해 사용할 가스량 지정 필수 함수 모금 - fund 현재 모금액 - currentCollection 모금액 수령 - withdraw 랜덤한 기부자의 주소와 기부금을 반환 (의사 난수 사용) - selectRandomFunder 난수 값 요청 (Chainlink VRF 사용) - selectRandomFunder2 난수 값 수신 시 이로 랜덤한 기부자의 주소와 기부금을 이벤트로 반환 (Chainlink VRF 사용) - fulfillRandomness fund() 요구사항 0.01 ether 이상으로 모금에 참여할 수 있다. 이더를 받을 수 있는 payable 함수 msg.value 트랜잭션에 얼마를 보냈는 지 알 수 있는 전역 변수 유효성 체크 전송한 이더가 최소 금액 조건을 만족하는지 판별 지정된 모금 시간 이내에만 참여할 수 있다. 조건문 if 논리형 변수 : bool 논리 연산자 : ==, !=, &amp;amp;&amp;amp;, | - 모금 유효 시간인지 판별 - 유효성 체크 함수 require(판별문, “에러 메시지”); 판별문이 true가 아닌 경우 “에러 메시지” 출력 후 함수 바로 종료 if문을 사용하는 것 보다 require를 사용하는 것이 훨씬 경제적이다. 모금이 완료되면 모금자를 저장한다. 주소형 address 이더리움 주소를 저장할 수 있는 자료형 초기값은 0x0 - msg.sender 메시지 송신자를 알 수 있는 전역변수 - 자료형의 배열 uint[4] fixedArray; uint[] dynamicArray; push() : 배열의 가장 뒤에 요소 추가 currentCollection() 요구사항 현재까지 모금된 금액을 누구나 확인할 수 있다. 함수의 반환문 작성 address(this).balance; return address(this).balance; - view 상태 변수에 변화를 가하지 않고 읽기만 하는 함수 withdraw() 요구사항 지정된 수령자만 호출할 수 있다. 이더 전송이 일어나는 payable함수 유효성 체크: 수령자가 맞는 지 확인 모금 종료 이후에만 호출할 수 있다. 유효성 체크: 모금이 종료되었는 지 확인 수령자에게 컨트랙트가 보유한 이더를 송금한다. 함수 modifier 작성 address의 멤버: balance, transfer 컨트랙트가 보유한 이더 &amp;lt;address&amp;gt;.balance 요청 주소에게 컨트랙트 보유 이더 송금 &amp;lt;address payable&amp;gt;.transfer(uint256 amount) selectRandomFunder 요구사항 keccak256를 활용하여 난수를 생성한다. 가스가 덜 생기도록 view로 작성 해당 함수가 안전한지 확인 모금자 배열 내에서 랜덤으로 모금자 주소와 해당 주소의 기부금 액수를 반환한다. 누구든지 요청 가능 selectRandomFunder2 요구사항 Chainlink VRF를 활용하여 Chainlink에 난수 값을 요청한다. 스마트컨트랙의 생성자만 호출할 수 있다. 유효성 체크: 스마트 컨트랙 생성자가 맞는 지 확인 스마트컨트랙이 가진 Link 토큰이 충분해야 호출할 수 있다. 유효성 체크: 가스로 필요한 Link 토큰의 양이 충분한지 확인한다. fulfillRandomness 요구사항 Chainlink VRF에서 난수값을 수신했을 때 동작한다. 모금자 배열 내에서 랜덤으로 모금자 주소와 해당 주소의 기부금 액수를 반환한다. 스마트컨트랙 내부에서만 호출 가능 Solidity 코드 (from Gist)리믹스로 위 코드 테스트 해보기체인링크 VRF(selectRandomFunder2)실행 결과스마트 컨트랙의 이벤트로 결과를 확인할 수 있다.이번 포스트에선 Solidity로 구체적인 기능을 가진 스마트 컨트랙을 작성해보았습니다.내용이 조금 어려울 수 있으나 코드와 주석을 잘 보시면 좀 더 심화적인 학습이 가능하리라 생각합니다.감사합니다." }, { "title": "블록체인 [이더리움을 통해 맛보기] (3)", "url": "/posts/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A7%9B%EB%B3%B4%EA%B8%B0-3/", "categories": "블록체인, 정보, 맛보기", "tags": "니체, 예찬군, 개발, 이더리움, 블록체인, 트랜잭션, Remix, IDE", "date": "2022-02-25 01:28:00 +0900", "snippet": "솔리디티 (Solidity)지난 포스트에선 Remix IDE에서 솔리디티 예제 파일을 컴파일 하고 배포하는 것을 해 보았습니다.오늘 할 것은 앞서 한 것들을 바탕으로 실제로 솔리디티를 배우고 소스를 코딩하는 것을 목표로 할 것입니다.솔리디티의 구조지난 사용했었던 예제 .sol 파일을 라인별로 분석해 솔리디티의 기본 구조를 알아봅시다.1 라인: 소스코드의 라이선스를 GPL-3.0으로 명시3 라인: Version Pragma: 소스코드가 이용하는 컴파일러 버전 명시 Sematic versioning을 따르고 있습니다.major.minor.patch ^(캐럿 연산자): ‘이상’ ← 이하 이상 할 때 그 이상입니다.9 라인: 컨트랙트의 범위를 나타내는 부분으로 중괄호로(28라인과 함께) 감싸져 있는 것을 보실 수 있습니다.11라인: 상태 변수(State Variable)이 선언되어 있습니다.State Variable 블록체인(contract storage)에 값이 저장되는 변수 상태 변수의 접근 제어자(Visibility)를 external, public, priavte와 같이 지정 가능 기본형, 고조체, 배열 등 다양한 자료형이 존재17라인: 함수(Function)이 선언되어 있습니다.Function 컨트랙트 단위의 기능(해당 스마트컨트랙이 할 수 있는 기능) 매개 변수, 제어자, 반환값 지정 가능 함수 내부서 상태 변수의 값을 변경하거나 읽을 수 있음 (Read&amp;amp;Write)솔리디티 문법기본형 Primitives 타입 논리형bool: true or false 정수형uint: unsigned integerint: signed integer 8 ~ 256 bit를 표현할 수 있으며, uint는 uint256과 같습니다 주소형address: 이더리움의 주소를 표현 바이트형bytes# or byte[]: 데이터를 바이트로 표현할 수 있습니다접근 제어자 Visibility   private internal public external 설명 - 컨트랙트 내에서만 접근 가능 - 현재 컨트랙트와 자식 컨트랙트에서 접근 가능 - 현재 컨트랙트, 자식 컨트랙트, 외부 컨트랙트 및 주소에서 접근 가능 - 외부 컨트랙트와 주소에서 접근 가능 (내부 접근 불가) State Variables O X O O Functions O O O O public으로 되어 있으면 외부 컨트랙트에서 해당 상태 변수를 바로 조회할 수도 있습니다.Solidity 예제// SPDX-License-Identifier: GPL-3.0pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract ParentTest { // State variables 테스트 string private privateVar = &quot;private variable test&quot;; string internal internalVar = &quot;internal variable test&quot;; string public publicVar = &quot;public variable test&quot;; // Private function function privateFunc() private pure returns (string memory) { return &quot;private test function called&quot;; } // Private fucntion을 테스트할 fucntion function testPrivateFunc() public pure returns (string memory) { return privateFunc(); } // Internal function function internalFunc() internal pure returns (string memory) { return &quot;internal test function called in Parent Contract&quot;; } // Internal fucntion을 테스트할 fucntion function testInternalFunc() public pure virtual returns (string memory) { return internalFunc(); } // Public functions 테스트 function publicFunc() public pure returns (string memory) { return &quot;public test function called&quot;; } // External functions function externalFunc() external pure returns (string memory) { return &quot;external test function called&quot;; }}contract ChildTest is ParentTest { // Internal function call be called inside child contracts. function testInternalFunc() public pure override returns (string memory) { return internalFunc(); } function testInternalFuncInChild() public pure returns (string memory){ // return privateFunc(); //에러 발생 return internalFunc(); }} 타 언어와 다른 특징으로는 함수의 return타입을 뒤에 선언한다는 점 internal 함수는 자식에서 호출이 가능 public 함수는 자식 뿐만 아닌 외부에서도 모두 호출이 가능 이 예시를 컴파일 해서 배포(배포 방법은 이전 포스트 참고)한 후 각 함수를 호출해보면 private 와 public과 같은 Visibility를 잘 확인하실 수 있습니다.자주 쓰는 자료형(타입)배열 Array 고정 길이, 가변 길이 배열이 존재합니다 배열형 자료구조 제어 방법index에 접근push, pop, delete 사용 함수 내에서 로컬 변수로 배열을 사용하기 위해서는 고정 길이로 선언해야 합니다 인덱스는 0부터 시작합니다 Solidity 예제 // SPDX-License-Identifier: GPL-3.0pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract Array { // 고정 길이 배열, 모든 원소는 0으로 초기화 됨 uint[10] public fixedSizeArr; // 가변길이 배열 uint[] public arr; // 초기화 안 한 상태 uint[] public arr2 = [1, 2, 3]; // 같은 라인에서 초기화도 같이 한 상태 // 배열의 접근(조회) 방법 function get(uint i) public view returns (uint) { return arr2[i]; } // 새 원소를 배열에 추가 // 이 함수가 호출되고 나면 배열의 크기를 확인해 보자 function push(uint i) public { arr.push(i); } // 배열에서 마지막 원소 삭제 // 이 함수가 호출되고 나면 배열의 크기를 확인해 보자 function pop() public { arr.pop(); } // delte 지시자를 사용하지만 실상은 특정 인덱스의 원소를 0으로 초기화시키는 동작을 함 // 이 함수가 호출되고 나면 배열의 크기를 확인해 보자 function remove(uint index) public { delete arr[index]; } // 배열의 크기를 반환하는 함수 function getLength() public view returns (uint) { return arr.length; } // 전체 배열을 반환하는 함수 function getArr() public view returns (uint[] memory) { return arr; } // 고정길이의 5칸짜리 배열을 생성하고 그것을 반환해주는 함수 function createArray() external pure returns (uint[] memory){ // create array in memory, only fixed size can be created uint[] memory a = new uint[](5); return a; }} 매핑 Mapping (자주 쓰임)예시를 통해 Mapping에 대해 다음을 배워봅시다. 매핑형 선언 접근, 추가, 삭제 매핑에 저장된 key의 목록을 얻을 수 있는 방법을 제공하지 않습니다Solidity 예제// SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract Mapping { // 매핑의 선언 // address(주소)를 uint로 매핑 mapping(address =&amp;gt; uint) public addrToUint; // 매핑 내의 키 값으로 값을 연결함 // 만약 해당하는 키가 없으면, 해당 타입의 기본 값을 반환함, 0. function get(address _addr) public view returns (uint) { return addrToUint[_addr]; } // 매핑 내 address 키에 해당하는 unit 값을 업데이트 function set(address _addr, uint _i) public { addrToUint[_addr] = _i; } // 매핑 내 address 키에 해당하는 unit 값을 기본 값으로 초기화, 0. function reset(address _addr) public { delete addrToUint[_addr]; } // 이런식으로 매핑의 값을 uint 배열 때처럼 불러오는 것은 불가능하다(에러) // 왜냐하면 매핑은 내부적으로 키를 저장해 놓는 것이 아니라 키 자체의 sha3해시에 의해 계산된 // 상태 메모리(state memory)에 저장된 값만 저장한다. 따라서 매핑의 조회는 원래 키가 제공되어야만 이를 계산하여 // 조회할 수 있게 구현되어 있기에 반드시 key가 있는 상태로 조회되어야 한다. // function getMapping() public view returns (mapping memory){ // return addrToUint; // }}사용자 선언 자료형 - Struct다음을 예시를 활용해 배워봅시다. Struct는 한글로 구조체라고도 합니다. 여러 자료형을 하나의 관점으로 묶어서 관리하고자 할 때 선언합니다. (마치 C언어 같음)struct Todo{ string todoText; bool isComplete;} 구조체의 Array, Mapping 의 값으로 지정이 가능합니다. 구조체 생성, 접근, 변경 함수 안에서 struct 상태 변수 참조 방법Solidity 예제// SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract Struct { //구조체의 선언 struct Todo { string text; bool boolean; } // 구조체의 배열 선언 Todo[] public structTodoArray; // 주소를 Todo 타입으로 매핑한다. mapping(address =&amp;gt; Todo) public addrToStruct; // 새로운 구조체를 생성해서 구조체 배열에 푸시 // 접근방식 1 function create1(string memory _text) public { structTodoArray.push(Todo(_text, false)); } // 접근방식 2 function create2(string memory _text) public { structTodoArray.push(Todo({text: _text, boolean: false})); } // 접근방식 3 function create3(string memory _text) public { Todo memory s; s.text = _text; structTodoArray.push(s); } // 구조체 배열 내 특정 인덱스의 Todo 인스턴스의 text를 변경 function updateText(uint _index, string memory _text) public { Todo storage s = structTodoArray[_index]; s.text = _text; } // 불리언(Boolean) 값을 토글 function updateBoolean(uint _index) public { Todo storage s = structTodoArray[_index]; bool current = s.boolean; s.boolean = !current; }}함수 function예제를 통해 다음을 배워봅시다. 함수 선언 방법 매개변수 유무, 반환 값 유무 view, pure 함수의 특징 2개 이상의 값을 반환하도록 선언// SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract Function { //여러 상태변수들 선언 uint public num = 1; uint public a = 1; string public s = &quot;hello solidity&quot;; bool public b = true; // 파라미터와 리턴값이 없는 함수 function addOne() public { num++; } // 하나의 파라미터와 리턴값이 있는 함수 function addNumber(uint x) public returns (uint) { num += x; return num; } // view - 상태변수들을 변경하지 않는다, 단순히 읽음. 가스가 안듬. function addAndReturn(uint x) public view returns (uint) { return num + x; } // pure - 상태 변수를 읽거나 수정하지 않음. 가스가 안듬. function add(uint x, uint y) public pure returns (uint) { return x + y; } // 여러 값들을 리턴하는 방법. function returnMany() public view returns (uint, string memory, bool) { return (a, s, b); }}Data location 배열이나 구조체처럼 복합타입(Complex type)의 경우 데이터의 위치(Data location)에 대한 어노테이션(Annotation)이 추가됩니다. 메모리(memory)와 저장소(storage), 콜데이터(calldata)로 구분되는 데이터의 위치는 각 타입별로 기본값이 있으나 필요에 따라서 재지정이 가능합니다. 메모리(memory) : 함수 내에서 임시로 데이터(storage 등)를 저장 할 때 사용하는 변수이다. 임시 데이터(temporary data) 저장소(storage) : 블록체인 상에 영구이 저장된다. 영구데이터(permanent data) 영역에 데이터가 저장되므로 다른 키워드에 비해 큰 비용을 초래한다. 콜데이터(calldata) : 리턴 파라미터를 제외한 외부 함수의 파라미터들, 데이터를 호출하고 메모리와 비슷하게 동작 → 함수에 전달되는 매개 변수처럼 변경 불가능하고 임시적인 데이터 저장 영역임. Solidity 예제 // SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract HamburgerFactory { struct Hamburger { string name; string status; } Hamburger[] Hamburgers; //햄버거를 초기화하고 배열에 햄버거를 넣음 function createHamburger(string memory _text) public { Hamburgers.push(Hamburger({name: _text, status: &quot;not eat&quot;})); } function eatStorageHamburger(uint _index) public { // storage로 선언된 myHamburger로 햄버거의 인덱스를 참조전달함 Hamburger storage myHamburger = Hamburgers[_index]; myHamburger.status = &quot;eaten&quot;; //따라서 수행되고 나면 값이 바뀜 } function eatMemoryHamburger(uint _index) public view{ // 메모리 변수의 선언 Hamburger memory myHamburger = Hamburgers[_index]; myHamburger.status = &quot;eaten&quot;; //상태가 변해도 블록체인에는 영향X. } function getStatusHamburger(uint _index) public view returns(string memory){ return Hamburgers[_index].status; //해당 값이 memory 형태에 담겨서 return됨 }} 제어문제어문은 타 언어와 매우 유사하므로 예시를 위주로 설명하겠습니다.조건문 If-Else//함수 내에서만 사용 가능함.if(x &amp;lt; 10){ return 0;} else if (x &amp;lt; 20){ return 1;} else { return 2;}// 삼항 연산자 return _x &amp;lt; 10 ? 1 : 2;반복문 for / while//함수 내에서만 사용 가능함.for (uint i = 0; i &amp;lt; 10; i++) { if (i == 3) { continue; } if (i == 5) { break; }}uint i;//함수 내에서만 사용 가능함.while (i &amp;lt; 10){ i++;} 반복문 사용시 주의사항: 이더리움은 튜링 완전머신으로 반복문을 제대로 지원하지만 함수를 수행할 때 수행 시간에 따라 가스가 발생하기 때문에 로직을 비효율적으로 하면 많은 돈이 소모될 수 있습니다.화폐 단위 화폐 단위에는 ether와 wei, gwei가 있습니다. 이더리움 내에선 소수점을 허용하지 않기 때문에 이와 같은 방식을 사용합니다.// SPDX-License-Identifier: UNLICENSEDpragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0;contract EtherUnits { uint public oneWei = 1 wei; uint public oneGwei = 1 gwei; uint public oneEther = 1 ether; // 1 wei is equal to 1 bool public isOneWei = 1 wei == 1; // 1 ether is equal to 10^18 wei bool public isOneEther1 = oneEther == 1e18; // 1 ether is equals to 10^9 gwei. bool public isOneEther2 = oneEther == 10**9 * oneGwei; // 1 gwei is equals to 10^9 wei. bool public isOneGwei = oneGwei == 10**9 * oneWei;}" }, { "title": "프로그래머스 Level2 카카오프렌즈 컬러링북 풀이", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-level2-%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%94%84%EB%A0%8C%EC%A6%88-%EC%BB%AC%EB%9F%AC%EB%A7%81%EB%B6%81/", "categories": "알고리즘, 프로그래머스", "tags": "니체, 예찬군, 알고리즘, 프로그래머스, BFS, DFS, 탐색, 카카오, LEVEL2", "date": "2022-02-23 03:08:29 +0900", "snippet": "카카오 프렌즈 컬러링북 https://programmers.co.kr/learn/courses/30/lessons/1829 본 게시글은 본 저작자의 저작권 보호를 위해 동일 유형의 가상의 문제를 만들어 풀이합니다. bfs라는 알고리즘 자체에 대한 저작권은 일반적으로 인정되지 않으며 않으며 문제에 표현된 생각이나 감정은 모두 제가 생각한 새로운 것으로 새로운 저작물로 취급됩니다.따라서 가상 문제의 저작권은 블로그 운영자가 가지며 모든 권한을 가집니다.동일 유형 유사 문제. 해양 탐험가의 산호초 모자이크해양 탐험가인 마린은 카일에게 산호초 모자이크 책에 들어갈 디자인을 그려달라고 부탁하여 여러 장의 디자인을 받았다. 모자이크의 색은 숫자로 표현된다. 여러 장의 디자인을 복잡성 순으로 모자이크 책에 넣고 싶었던 마린은 구역이 많으면 색칠하기가 번거로워 어려워진다는 사실을 발견하고 디자인의 복잡성을 구역의 수로 정의하였다.구역은 상하좌우로 연결된 같은 패턴의 공간을 의미한다.디자인에 몇 개의 구역이 있는지와 가장 큰 구역의 크기는 얼마인지 계산하는 프로그램을 작성해보자.+-+-+-+-+|1|2|2|3|+-+-+-+-+|1|1|3|6|+-+-+-+-+|4|5|5|6|+-+-+-+-+|4|4|6|6|+-+-+-+-+위의 디자인은 총 6개 구역으로 이루어져 있으며, 가장 큰 구역은 6으로 크기는 4이다.입력 형식입력은 디자인의 크기를 나타내는 m과 n, 그리고 디자인을 나타내는 m × n 크기의 2차원 배열 pattern으로 주어진다. 제한조건은 아래와 같다.1 &amp;lt;= m, n &amp;lt;= 50pattern의 원소는 0 이상 100 이하의 임의의 값이다.pattern의 원소 중 값이 0인 경우는 색칠하지 않는 구역을 뜻한다.출력 형식출력 타입은 원소가 두 개인 정수 배열이다. 디자인에 몇 개의 구역이 있는지와 가장 큰 구역은 몇 칸으로 이루어져 있는지를 출력한다.유사 유형 문제 풀이pattern[rol][col]==-1이 아닌 지점을 기준으로 같은 값의 영역을 계속 -1로 만들면서 탐색하는 bfs 알고리즘을 사용했다.import java.util.*;class Solution { static Queue&amp;lt;int[]&amp;gt; queue; public int[] solution(int m, int n, int[][] pattern) { int numberOfArea = 0; int maxSizeOfOneArea = 0; int[][] cpic = new int[m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { cpic[i][j] = pattern[i][j]; } } queue = new LinkedList&amp;lt;&amp;gt;(); int temp = 0; for(int i =0, j=0; i&amp;lt;m; i++){ for(j=0; j&amp;lt;n; j++){ temp = bfs(i,j,m,n, cpic); if(temp &amp;gt; 0) { numberOfArea++; maxSizeOfOneArea = Math.max(temp, maxSizeOfOneArea); } } } int[] answer = new int[2]; answer[0] = numberOfArea; answer[1] = maxSizeOfOneArea; return answer; } // pattern[rol][col]==-1이 아닌 지점을 기준으로 같은 값의 영역을 계속 -1로 만들면서 탐색하는 bfs private int bfs(int row, int col, int m, int n, int[][] pattern){ if(pattern[row][col] == 0) return 0; int thisColor = pattern[row][col]; queue.offer(new int[]{row,col}); pattern[row][col] = 0; int sum = 0; int dr[] = {-1, 1, 0, 0}; int dc[] = {0, 0, -1, 1}; while(!queue.isEmpty()){ int[] pos = queue.poll(); int trow = pos[0], tcol = pos[1]; sum++; for(int d=0; d&amp;lt;4; d++){ int nr = trow + dr[d]; int nc = tcol + dc[d]; if(nr == -1 || nr == m || nc == -1 || nc == n || pattern[nr][nc] == 0 || pattern[nr][nc] != thisColor) continue; queue.offer(new int[]{nr,nc}); pattern[nr][nc] = 0; } } return sum; }}" }, { "title": "블록체인 [이더리움을 통해 맛보기] (2)", "url": "/posts/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A7%9B%EB%B3%B4%EA%B8%B0-2/", "categories": "블록체인, 정보, 맛보기", "tags": "니체, 개발, 이더리움, 블록체인, 트랜잭션, Remix, IDE, 테스트넷, Besu, RPC", "date": "2022-02-23 00:27:47 +0900", "snippet": "스마트 컨트랙(Smart Contract)이란?1990년대에 Nick Szabo가 소개한 개념으로 기존의 문서 계약을 디지털 형식으로 바꾼 것입니다.디지털 형식으로 명시된 서약(commitment)들의 집합이라고 할 수 있음!전혀 스마트하지 않아서 다소 잘못된 용어지만 자리잡음블록체인에서의 정의불변의 컴퓨터 프로그램 컴퓨터 프로그램 불변(immutable)한 번 배포되면 변경 불가 결정적(deterministic) 실행한 결과가 모두 같음. EVM(Ethereum virtual machine) 위에서 동작 탈중앙화된 World Computer 동일한 상태를 유지Smart Contract를 작성하는 언어 Solidity(가장 대중화되어 있고 상대적으로 사용하기 쉬움) LLL Viper AssemblySmart Contract의 배포와 호출Smart Contract Code → 컴파일 → EVM Bytecode, ABI(Application Binary Interface) in JSON → 트랜잭션 생성→{... from: deployer&#39;s address, to: 0x, data: bytecode,...}→ 서명 → Sending transaction 스마트 컨트랙에는 바이트코드가 담기게 됩니다..스마트컨트랙 또한 주소가 생성되는데 이를 컨트랙트 주소(CA: Contract Address)라고 합니다.실제로 스마트 컨트랙을 Solidity로 작성해 보기 위해 우리는 Remix IDE를 사용합니다.Remix IDE로 실제 배포 및 호출 해보기 이더리움 재단이 제공하는 스마트컨트랙을 쉽게 사용할 수 있게 웹페이지에서 제공하는 통합 개발 환경스마트 컨트랙 배포우리는 여기서 기본적으로 제공되는 예제 contract인2번 영역에서 contract 폴더 내의 1_Storage.sol 을 활용해보겠습니다!컴파일은 1번 영역의 2번째 버튼을 사용합니다.이더리움은 2015년에서부터 엄청 많은 업데이트가 있었는데 그러는 중 컴파일러 문법이 달라지기도 하고 내부적인 구현이 달라지기도 했습니다.따라서 컴파일러의 버전을 pragma solidity 라는 지시자로 언제부터 어디까지의 버전을 따른다는 것을 명시합니다. 컴파일을 문제없이 완료하면 왼쪽과 같이 컨트랙트가 나타나게 됩니다.만약 문법상의 에러가 난다면 터미널 영역에서 에러가 표시됨!컴파일 완료시 → ABI와 Bytecode가 생성됨. 1번 영역에서 다시 파일 익스플로러로 넘어오면 컴파일한 sol파일이 있는 폴더에 artifacts 라는 폴더가 생성되고 컴파일 결과를 확인할 수 있습니다!여기까지 스마트 컨트랙의 배포 과정 중 컴파일로 ABI 생성까지 이루어진 것!그럼 이걸 실제로 배포를 해야합니다 이렇게 컴파일러에서 초록색으로 체크가 되어 있으면 실제로 배포를 할 수 있다는 것인데 실제 배포하기 전에 간단하게 클라이언트의 가상 환경에서 테스트를 해볼 수 있게 제공합니다. (ENVIRONMENT 부분)JavaScript VM 선택시 총 10개의 테스트해볼 수 있는 이더리움 계정을 준다.[1번] 디플로이(Deploy) 선택시 해당 스마트 컨트랙이 [2번] 배포(가상환경에/_)되는 것을 볼 수 있습니다.또한 3번을 보면 배포가 완료되어 가스비가 나간것을 확인할 수 있습니다.그리고 터미널에서 배포 부분을 크게 보면 어떤 지갑에서 나갔고 가스를 얼마 썼고 등의 확인을 할 수 있습니다.그럼 여기까지 스마트컨트랙의 배포 과정이 완료된 것이고 우리는 테스트만을 목적으로 한 것이기 때문에 아직 이더리움 메인넷을 활용하진 않은 것입니다.→ 브라우저 기반 가상환경에서 즉각적으로 처리되는 테스트를 한 것배포된 컨트랙트의 주소값은 왼쪽 아래에서 확인 가능그렇다면 이젠 배포가 끝났으니 배포된 스마트 컨트랙을 호출할 차례입니다.스마트 컨트랙 호출 Deployed Contracts 열기각각의 store 버튼과 retrieve 버튼이 각 우리가 컴파일한 1_Storage.sol의 function을 가리킨다는 것을 알 수 있습니다여기에서 retrieve 버튼을 눌러보시면 number의 숫자를 get할 수 있습니다.자바에서 get, set 메서드를 작성하는 것처럼 그러한 동작을 하는 함수라는 것을 알 수 있습니다.아래쪽의 decoded output을 보시면 0이라는 숫자가 받아진 것을 보실 수 있습니다.우리의 코드에선 number를 단순 선언만 해줬었는데 0이라는 값이 초기화 되어 있다는 것도 알 수 있죠.또한 이런 retrieve 함수는 호출했을 때 가스가 들지 않지만이렇게 값을 바꾸는 함수를 호출할 경우 가스가 사용되게 됩니다. (맨 아래 함수의 호출 결과 상세)→ 전세계의 컴퓨터에서 해당 값을 바꾸라는 얘기가 되므로 일을 시키는데에는 가스가 필요함!이것이 단순한 컴퓨터랑은 무엇이 다른가?→ 한 번 값을 1000으로 바꾸고 나면 다시 스마트 컨트랙으로 값을 바꾸기 전까진 전세계의 컴퓨터들이 이 값을 1000 증명하기 때문에 불변의 속성을 가집니다.모든 것을 프로토콜대로만 제어할 수 있다! 라는 것입니다.우리는 스마트컨트랙 배포를 끝마쳤으니 이제 배포한 사람뿐만 아니라 이 스마트 컨트랙을 아예 다른 제 3자가 활용할 수 있는데배포한 스토리지에서 컨트랙트 주소를 복사하고 이를 삭제한 후 다른 계정으로도 똑같이 테스트 할 수 있습니다.이와 같이 이더리움 주소를 바꿨고 100 ether가 그대로 있지만At Address버튼을 통해 컨트랙트 주소를 추가하고 아래에서 배포된 컨트랙트를 다시 불러올 수 있습니다.그리고 여기서 retrieve를 하면 예전에 저장했던 값인 1000이 보이는 것을 확인하실 수 있습니다.여기까지 블록체인 [이더리움을 통해 맛보기] (2) 였습니다.감사합니다.해보면 좋은 것들Remix에서 3_Ballot.sol 배포해보기상태 변수의 의미 알기 chairman, proposals 변수를 호출해보고 어떤 값이 할당되어 있는지 알기함수 및 변수 호출하기 아직 사용하지 않은 계정을 선택해 3_Ballot.sol 배포한 컨트랙트의 delegate() 함수 호출해보기 호출자(계정)를 변경하고 proposals의 index중 하나를 입력하고 vote()를 호출해보기 2에서 호출한 계정의 voters 정보 확인해보기3_Ballot을 Ropsten 테스트넷에 배포하기 Remix환경과 MetaMask를 이용하여 Ropsten 네트워크에 3_Ballot.sol 컨트랙트를 배포해보기" }, { "title": "블록체인 [이더리움을 통해 맛보기] (1)", "url": "/posts/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80%EC%9D%84-%ED%86%B5%ED%95%B4-%EB%A7%9B%EB%B3%B4%EA%B8%B0-1/", "categories": "블록체인, 정보, 맛보기", "tags": "니체, 개발, 이더리움, 블록체인, 트랜잭션, 테스트넷, Besu, RPC", "date": "2022-02-22 01:31:34 +0900", "snippet": "1. 이더리움, 트랜잭션우리의 목적은 빠르게 이더리움을 이해하고 실사용을 해보는 것입니다.이더리움은 온라인상에서 인터넷으로 이어진 노드들로(여러 컴퓨터) 유지되고 있는 분산 데이터베이스의 일종이라 생각하면 되는데이더리움 메인넷에서 접속되는 클라이언트 종류들의 통계는 다음과 같습니다. 여기서 클라이언트란? 네트워크 노드로 참여하는 끝단을 말함 RPC(Remote Procedure Call)요청을 송신하고 결과를 수신받는 엔드포인트임 클라이언트들은 여러 종류가 있는데 우리가 여기서 테스트를 해볼 클라이언트는 Besu입니다.Besu는 이더리움의 클라이언트 소프트웨어를 개조해 퍼블릭 및 프라이빗 네트워크 방식의 사용 모두를 위해 기업 친화적으로 설계된 클라이언트라고 합니다. 프라이빗 네트워크 공개되어 있는 클라이언트 소프트웨어로 프라이빗 네트워크 구축 가능 besu는 엔터프라이즈 환경에 맞게 개량된 하이퍼렛저의 이더리움 프로젝트 우리는 이제 이를 직접 사용해보기 위해 테스트넷을 사용해볼 것인데퍼블릭 네트워크가 이제 진짜 현금성 가치를 가지는 거래가 이루어지는 네트워크라고 한다면테스트넷은 테스트용으로 완전히 분리된 별도의 네트워크입니다. (그리고 이더 테스트넷은 이더 가격이 무료임!)그 중에서 우린 Ropsten 테스트넷에서 요청, 트랜잭션을 처리해볼 예정입니다.2. Ropsten 실습 환경 준비MetaMask 지갑 지갑이란? 블록체인 네트워크를 사용할 수 있도록 계정의 개인키(private key)를 관리하는 프로그램 개인키로 사인(sign)하여 트랜잭션을 보냄 계정 생성 절차(내부 원리) 계정 생성 절차는 [Mastering Ethereum] 3장 키와 주소, 이 포스트를 참고하시면 도움이 될 것 같습니다.간단 정리 개인키 생성 256bit의 무작위 숫자 -&amp;gt; 64자리 타원곡선전자서명 알고리즘(ECDSA, secp256) Keccak-256 hashing 마지막 20Byte를 떼서 계정주소로 사용 계정주소 완성 이 포스트의 목적을 위해지갑과 네트워크를 쉽게 사용하려면 우선 메타마스크의 설치 및 설정과정들이 필요합니다. 메타마스크 확장 프로그램 설치(Chrome) &amp;gt; Ropsten 테스트넷 네트워크 연결을 위한 준비 테스트넷 옵션 활성화 이 옵션 활성화 하면 이더리움 메인넷 클릭시 다른 테스트 네트워크가 보인다. 여기서 Ropsten 테스트 네트워크를 클릭하자 Faucet으로 ETH받기 초록 버튼을 누르면 ETH가 들어옴3. 실제로 RPC 보내고 결과 수신 받아보기이제 사전 준비가 모두 끝났습니다! 실제로 지갑으로 거래가 가능한 상태입니다.여기서 메타마스크의 기능을 십분 활용하기 위해 이더리움 프로바이더를 사용할 것 입니다. 프로바이더(Provider)란? 클라이언트를 통해 이더리움 네트워크에 접근할 수 있도록 제공된 Javascript 객체(Object) 이더리움 Provider로 RPC 요청하기(실습 부분 크롬 메타마스크 확장프로그램이 깔려있는 상태에서 F12 Console창에서 ethereum이란 키워드를 쳐보시면 확인하실 수 있습니다. 메타마스크 Docs이 Console창에서 사용 가능한 모든 메타마스크 명령어는 메타마스크 DOCS에서 제공되고 있습니다.우리가 여기서 봐야할 것은 이더리움 프로바이더의 메서드입니다.이제 여기서 명시되어 있는 방법대로 이더리움의 맨 마지막 블럭의 번호를 한 번 조회해보겠습니다.ethereum .request({ method: &quot;eth_blockNumber&quot;, params: [], }) .then((result) =&amp;gt; { console.log(result); }) .catch((error) =&amp;gt; { // If the request fails, the Promise will reject with an error. });parseInt(&quot;0xb70b6d&quot;, 16);결과가 잘 나오네요. 이더리움 프로바이더에서 RPC를 제대로 송신하고 수신을 받아냈습니다.수신된 값은 16비트로 표현된 값이므로 parseInt를 통해 해석해줘야 합니다여기서 Promise로 되어 있는 결과값은 비동기적인 메서드를 호출할 때 값을 받아온다는 일종의 약속을 말하는 것인데이 게시글에서 다룰 내용은 아닌 것 같고 관련해서 더 궁금하신 분들은 찾아보시면 좋을듯 합니다.물론 이런 단순한 것들 이외에도wallet_getPermissions로 메타마스크의 권한을 얻고 eth_sendTransaction으로 트랜잭션을 보낼 수도 있습니다.더 많은 것들을 해보고 싶으신 분들은메타마스크 DOCS와메타마스크 API 놀이터를참고하시면 좋을듯 합니다.감사합니다." } ]
