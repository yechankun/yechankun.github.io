<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://yechankun.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://yechankun.github.io/" rel="alternate" type="text/html" hreflang="ko-KR" /><updated>2023-04-27T22:29:15+09:00</updated><id>https://yechankun.github.io/feed.xml</id><title type="html">니체의 개발 인생</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle><entry><title type="html">Git 소개 및 기본 명령어</title><link href="https://yechankun.github.io/posts/Git-%EC%86%8C%EA%B0%9C-%EB%B0%8F-%EA%B8%B0%EB%B3%B8-%EB%AA%85%EB%A0%B9%EC%96%B4/" rel="alternate" type="text/html" title="Git 소개 및 기본 명령어" /><published>2023-04-25T21:44:00+09:00</published><updated>2023-04-25T21:44:00+09:00</updated><id>https://yechankun.github.io/posts/Git-%EC%86%8C%EA%B0%9C-%EB%B0%8F-%EA%B8%B0%EB%B3%B8-%EB%AA%85%EB%A0%B9%EC%96%B4</id><content type="html" xml:base="https://yechankun.github.io/posts/Git-%EC%86%8C%EA%B0%9C-%EB%B0%8F-%EA%B8%B0%EB%B3%B8-%EB%AA%85%EB%A0%B9%EC%96%B4/"><![CDATA[<p><img class="col-md-5" src="/assets/img/develop/git.png" />
<em>Git은 현존 최고의 버전컨트롤 방식이다!</em></p>

<blockquote>
  <p>💡 깃은 <code class="language-plaintext highlighter-rouge">형상 관리 도구</code>(Configuration Management Tool)이자<br />
<code class="language-plaintext highlighter-rouge">소스 제어 관리 도구</code> (Source-control management Tool)입니다.</p>
</blockquote>

<ul>
  <li>파일 변화를 시간에 따라 기록 → 원할 때 꺼내서 사용</li>
</ul>

<p><img class="col-md-5" src="/assets/img/develop/notvcs.png" />
<em>진짜 최종의…최종..</em></p>

<ul>
  <li>Jira 등의 소프트웨어를 제공하는 Atlassian 공식, 왜 Git을 써야하는가?
<a href="https://www.atlassian.com/git/tutorials/why-git">Why Git | Atlassian Git Tutorial</a>
    <ul>
      <li>기능 분기 워크플로</li>
      <li>분산 개발
        <ul>
          <li>SVN은 개별 개발자만의 개발 이력 X</li>
        </ul>
      </li>
      <li>풀 리퀘스트</li>
      <li>지역사회 - 이미 깃은 널리 알려짐</li>
      <li>빠른 릴리즈 - 모놀리식 릴리즈보다 빠른 마이크로서비스 릴리즈가 가능함</li>
    </ul>
  </li>
</ul>

<h2 id="명령어의-중요성">명령어의 중요성</h2>

<blockquote>
  <p>💡 현업에선 GUI도 많이 쓰지만 Git Bash 명령어를 모르고 쓰는 경력자 분들은 없습니다.</p>
</blockquote>

<h3 id="모든-명령어를-사용-방법까지-하나하나-알고-있을-필요-x">모든 명령어를 사용 방법까지 하나하나 알고 있을 필요 X</h3>

<p>→ 어떤 명령이 있는지, 어떤 상황에서 어떤 방식을 쓸 수 있는지 이해하는 것이 중요합니다</p>

<h2 id="주요-명령어-모음">주요 명령어 모음</h2>

<h3 id="설정-및-초기화"><strong><a href="https://www.notion.so/Git-bash-459a84f7749a4d9e8c533f5169c621ed">설정 및 초기화</a></strong></h3>

<ol>
  <li>전역 사용자명/이메일 구성하기</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>git config - <span class="nt">-global</span> user.name “Your name”

<span class="nv">$ </span>git config - <span class="nt">-global</span> user.email “Your email address”
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>저장소별 사용자/이메일 구성</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>git config user.name “Your name”

<span class="nv">$ </span>git config user.email “Your email address”
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>각종 조회</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c"># 전역 설정 정보 조회</span>
<span class="nv">$ </span>git config - <span class="nt">-global</span> - <span class="nt">-list</span>
<span class="c"># 저장소별 설정 정보 조회</span>
<span class="nv">$ </span>git config - <span class="nt">-list</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>새로운 저장소 초기화 또는 복제</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="c"># 초기화</span>
<span class="nv">$ </span><span class="nb">mkdir</span> /path/newDir
<span class="nv">$ </span><span class="nb">cd</span> /path/newDir
<span class="nv">$ </span>git init

<span class="c"># 저장소 복제. []는 생략 가능-현재 위치로 복제</span>
<span class="nv">$ </span>git clone &lt;저장소 url&gt; <span class="o">[</span>폴더 위치]
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="기본-사용법">기본 사용법</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c"># 파일 스테이징 및 커밋</span>
<span class="nv">$ </span>git add &lt;파일&gt;
<span class="nv">$ </span>git commit <span class="nt">-m</span> <span class="s2">"&lt;메시지&gt;"</span>

<span class="c"># 파일 일부 스테이징</span>
<span class="nv">$ </span>git add <span class="nt">-p</span> &lt;파일&gt; <span class="o">[</span>파일...]

<span class="c"># 대화 모드로 파일 추가</span>
git add <span class="nt">-i</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="브랜치-관련-명령">브랜치 관련 명령</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="c"># 로컬(지역) 브랜치 목록 보기</span>
<span class="nv">$ </span>git branch

<span class="c"># 리모트(원격) 브랜치 목록 보기</span>
<span class="nv">$ </span>git branch <span class="nt">-r</span>

<span class="c"># 모든 브랜치 목록 보기</span>
<span class="nv">$ </span>git branch <span class="nt">-a</span>

<span class="c"># 현재 브랜치에서 새로운 브랜치 생성</span>
<span class="nv">$ </span>git branch &lt;새로운 브랜치 명&gt;

<span class="c"># 브랜치 체크아웃</span>
<span class="nv">$ </span>git checkout &lt;브랜치명&gt;

<span class="c"># 다른 브랜치를 현재 브랜치로 병합</span>
<span class="nv">$ </span>git merge &lt;브랜치&gt;

<span class="c"># 커밋 일부만 가져와서 합치기 e.g. $ git cherry-pick 76ae30ef</span>
<span class="nv">$ </span>git cherry-pick &lt;커밋해시&gt;

<span class="c"># 브랜치 삭제</span>
<span class="nv">$ </span>git branch <span class="nt">-d</span> &lt;삭제할 브랜치명&gt;
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="저장소-관련-명령">저장소 관련 명령</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="c"># 새로운 원격 저장소 추가</span>
<span class="nv">$ </span>git remote add &lt;저장소명&gt; &lt;저장소 url&gt;

<span class="c"># 모든 원격 브랜치 목록 보기</span>
<span class="nv">$ </span>git branch <span class="nt">-r</span>

<span class="c"># 병합 없이 원격저장소의 변경사항을 로컬 브랜치로 가져오기</span>
<span class="c"># 직접 병합 작업을 해야함, &lt;저장소명&gt;은 보통 orgin</span>
<span class="nv">$ </span>git fetch <span class="o">[</span>&lt;저장소명&gt; &lt;브랜치명&gt;]

<span class="c"># 자동 병합작업을 거쳐 로컬 브랜치와 합침</span>
<span class="c"># git feth + git merge와 같음</span>
<span class="nv">$ </span>git pull <span class="o">[</span>&lt;저장소명&gt; &lt;브랜치명&gt;]

<span class="c"># 원격 저장소의 브랜치에 변경사항 반영</span>
<span class="nv">$ </span>git push &lt;저장소명&gt; &lt;브랜치명&gt;
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="참고-자료">참고 자료</h2>

<p><a href="https://git-scm.com/docs">Reference</a></p>

<h2 id="마무리">마무리</h2>

<p>저는 Git을 쓸 때 과거엔 깃크라켄을 쓰긴 했지만 요즘은 IDE에 포함되는 확장이나 기능을 사용하면서 추가로 콘솔 명령을 사용하는 것이 더 좋더라구요.<br />
깃 활용은 귀찮지만서도 꼭 해야 하는 작업이죠… 🥲</p>

<p>앞으로도 좋은 개발자가 되기 위해 귀찮아도 제 양식이 된다 생각하고 시간을 투자하려고 합니다.</p>]]></content><author><name></name></author><category term="[&quot;개발&quot;, &quot;Git&quot;]" /><category term="깃" /><category term="Git" /><category term="도구" /><category term="깃허브" /><category term="미러링" /><category term="깃랩" /><category term="복사" /><summary type="html"><![CDATA[Git은 현존 최고의 버전컨트롤 방식이다!]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://yechankun.github.io/assets/img/develop/git.png" /><media:content medium="image" url="https://yechankun.github.io/assets/img/develop/git.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Git mirror, 원격저장소에 미러링 하는 법</title><link href="https://yechankun.github.io/posts/Git-mirror-%EB%B0%A9%EB%B2%95/" rel="alternate" type="text/html" title="Git mirror, 원격저장소에 미러링 하는 법" /><published>2023-04-24T23:15:00+09:00</published><updated>2023-04-25T22:17:22+09:00</updated><id>https://yechankun.github.io/posts/Git-mirror-%EB%B0%A9%EB%B2%95</id><content type="html" xml:base="https://yechankun.github.io/posts/Git-mirror-%EB%B0%A9%EB%B2%95/"><![CDATA[<h2 id="다른-깃저장소에-기존-저장소를-옮기고-싶을-때">다른 깃저장소에 기존 저장소를 옮기고 싶을 때</h2>

<p><img class="col-md-5" src="/assets/img/develop/github.png" />
<em>항상 깃허브를 쓰고 싶지만 마음대로 될리가..</em></p>

<p>간혹가다 깃랩에서 깃허브로 리포지토리를 옮기고 싶거나 깃허브에서 다른 리포지토리로 기존 리포지토리를 옮기고 싶을 때가 있다.</p>

<p>그럴 때 적용 가능한 팁</p>

<blockquote>
  <p>💡 <strong>이동할 저장소에는 아무것도 생성을 안한 상태로 진행해 주세요.</strong></p>
</blockquote>

<h3 id="원본-저장소-이력-복사">원본 저장소 이력 복사</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>git clone <span class="nt">--mirror</span> <span class="o">[</span>원본 저장소 주소]
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="디렉토리-이동">디렉토리 이동</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nb">cd</span> <span class="o">[</span>원본 저장소 이름].git
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="이동할-원격-저장소-경로-지정">이동할 원격 저장소 경로 지정</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>git remote set-url <span class="nt">--push</span> origin <span class="o">[</span>이동할 저장소 주소]
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="push">Push</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>git push <span class="nt">--mirror</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="완료">완료!</h2>]]></content><author><name></name></author><category term="개발" /><category term="Git" /><category term="깃" /><category term="Git" /><category term="도구" /><category term="깃허브" /><category term="미러링" /><category term="깃랩" /><category term="복사" /><summary type="html"><![CDATA[다른 깃저장소에 기존 저장소를 옮기고 싶을 때]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://yechankun.github.io/assets/img/develop/github.png" /><media:content medium="image" url="https://yechankun.github.io/assets/img/develop/github.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 줄 세우기 파이썬(Python) 풀이</title><link href="https://yechankun.github.io/posts/%EB%B0%B1%EC%A4%80-%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0/" rel="alternate" type="text/html" title="백준 줄 세우기 파이썬(Python) 풀이" /><published>2023-04-24T10:42:00+09:00</published><updated>2023-04-24T10:42:00+09:00</updated><id>https://yechankun.github.io/posts/%EB%B0%B1%EC%A4%80-%EC%A4%84%20%EC%84%B8%EC%9A%B0%EA%B8%B0</id><content type="html" xml:base="https://yechankun.github.io/posts/%EB%B0%B1%EC%A4%80-%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0/"><![CDATA[<h2 id="문제">문제</h2>

<ul>
  <li>백준 줄 세우기</li>
  <li>난이도: Gold3</li>
  <li>https://www.acmicpc.net/problem/2252</li>
</ul>

<h2 id="풀이-알고리즘-위상-정렬">풀이 알고리즘: 위상 정렬</h2>

<p>이 문제를 풀이한 과정과 접근법을 공유함니다.</p>

<ol>
  <li>N명의 학생을 줄 세우려는데 일부 학생의 순서만 알고 있다면 이것은 위상 정렬로 풀 수 있는 문제다.</li>
  <li>위상 정렬은 중간 연결 순서가 정해진 순서를 정렬할 때 효과적인데 이 문제는 마침 일부만 순서가 정해져 있다.</li>
  <li>graph를 통해 순서를 입력 받고 진입차수를 초기화한다.</li>
  <li>진입 차수가 0인 것들을 큐에 넣고 진입차수가 새롭게 0이 되면 다음 큐의 끝에 넣는다.</li>
  <li>큐가 아예 빌 때까지 순회한다.</li>
  <li>순회하면서 출력하면 그것이 정답이다.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>
<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())</span>

<span class="c1"># 위상 정렬로 문제를 풀 수 있어 보인다.
</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">indegree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())</span>
    <span class="n">graph</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">indegree</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># 진입 차수가 0인 것들을 큐에 넣는다.
</span>
<span class="n">q</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">while</span> <span class="n">q</span><span class="p">:</span>
    <span class="n">next_q</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">now</span> <span class="ow">in</span> <span class="n">q</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">now</span><span class="p">]:</span>
            <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">next_q</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">next_q</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="후담">후담</h2>

<p>필자는 예전에 위상정렬로 풀면 안되는 카카오 코딩테스트의 양과 늑대가 나왔던 문제를 위상정렬로 풀었었다.</p>

<p>위상정렬을 알지도 못할 때 적용해서 풀어보려고 했다가 코딩테스트에서 낭패를 본 적이 있었는데 위상정렬이란걸 제대로 알게 되고 어떨 때 이와 같이 접근해야 하는지 확실히 알아가자.</p>]]></content><author><name></name></author><category term="알고리즘" /><category term="백준" /><category term="알고리즘" /><category term="줄" /><category term="세우기" /><category term="파이썬" /><category term="Python" /><category term="위상정렬" /><category term="위상" /><summary type="html"><![CDATA[문제]]></summary></entry><entry><title type="html">Jekyll, Html 캐시 비활성화 방법 cache-busting</title><link href="https://yechankun.github.io/posts/Jekyll-Blog-%EC%BA%90%EC%8B%9C%EB%B2%84%EC%8A%A4%ED%8C%85/" rel="alternate" type="text/html" title="Jekyll, Html 캐시 비활성화 방법 cache-busting" /><published>2023-04-23T15:32:00+09:00</published><updated>2023-04-24T00:13:02+09:00</updated><id>https://yechankun.github.io/posts/Jekyll-Blog-%EC%BA%90%EC%8B%9C%EB%B2%84%EC%8A%A4%ED%8C%85</id><content type="html" xml:base="https://yechankun.github.io/posts/Jekyll-Blog-%EC%BA%90%EC%8B%9C%EB%B2%84%EC%8A%A4%ED%8C%85/"><![CDATA[<h2 id="지킬-블로그-대공감-레이아웃을-수정했는데-갱신이-안돼">지킬 블로그 대공감.. 레이아웃을 수정했는데 갱신이 안돼!</h2>

<p><img class="col-md-5" src="/assets/img/blog/cache_1.png" />
<em>분명 레이아웃을 수정했는데 왜 안되지… 웨.. 웨? (냐옹)</em></p>

<p>Github를 이용해 Jekyll 블로그를 하다보면 레이아웃과 같은 화면을 분명 바꿨음에도 갱신이 되지 않는 경우가 있다.</p>

<p>그것은 바로 웹캐시(Web cache)로 인해 발생하는 문제인데 브라우저가 사이트의 탐색을 빠르게 하기 위해 브라우저 내부에 html, js, css 등의 자산들을 기록하고 재방문시 이를 가져오는 방식을 택하기 때문이다.</p>

<p>본론부터 말하면 어느정도 해결할 방법들이 있다. 여러 해결법 중에 택해서 사용하자.</p>

<h2 id="메타-태그-활용으로-해결-캐시-사용-자체를-비활성화">메타 태그 활용으로 해결 (캐시 사용 자체를 비활성화)</h2>

<p>자주 갱신되는 목적의 블로그에선 캐시를 사용하지 않기 위해 다음과 같은 방법을 적용하는 것도 괜찮은 방법이다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="c">&lt;!-- 다음 코드를 html 헤더에 삽입--&gt;</span>

<span class="c">&lt;!--
no-cache : 캐시 사용 전 재검증을 위한 요청을 강제
no-store : 클라이언트의 요청, 서버의 응답 등을 저장 안함
must-revalidate : 캐시 사용 전 반드시 만료된 것인지 검사
(http 1.1에서 적용됨)
--&gt;</span>
<span class="nt">&lt;meta</span>
  <span class="na">http-equiv=</span><span class="s">"Cache-Control"</span>
  <span class="na">content=</span><span class="s">"no-cache, no-store, must-revalidate"</span>
<span class="nt">/&gt;</span>
<span class="c">&lt;!--
특정시간 이후엔 리소스가 만료됐음을 의미. 0, -1 등은 즉시 만료
Ex) Expires: Wed, 21 Oct 2015 07:28:00 GMT
--&gt;</span>
<span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Expires"</span> <span class="na">content=</span><span class="s">"0"</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- 위의 명시된 날짜 이후가 되면 페이지가 캐싱되지 않는다.(1990년 이후 쭉) --&gt;</span>
<span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Expires"</span> <span class="na">content=</span><span class="s">"Mon, 06 Jan 1990 00:00:01 GMT"</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- 페이지 로드시마다 페이지를 캐싱하지 않는다.(HTTP 1.0) --&gt;</span>
<span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Pragma"</span> <span class="na">content=</span><span class="s">"no-cache"</span> <span class="nt">/&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="빌드-버전build-version-사용">빌드 버전(Build version) 사용</h2>

<p>브라우저는 파일명을 기반으로 캐시를 저장한다. 따라서 js, css 등 html에 삽입되어 사용되는 에셋에 캐싱을 이용하지 않으려면 파일명을 달라지게 해주어야 한다.</p>

<h3 id="github-pages-를-이용해서-jekyll-사이트를-빌드할-경우">Github Pages 를 이용해서 Jekyll 사이트를 빌드할 경우</h3>

<p>Ruby와 Liquid 템플릿 언어가 적용된 Jekyll에서 활용 가능하다. (이게 보통 기본 사양임)</p>

<p><code class="language-plaintext highlighter-rouge">_include/</code> 위치에 <code class="language-plaintext highlighter-rouge">build_versions.html</code>이란 파일을 만들어보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>&lt;!--  build_versions.html --&gt;
{%- if site.github.build_revision and jekyll.environment == "production" -%}
  {%- assign build_version = site.github.build_revision -%}
{%- else -%}
  {%- assign build_version = site.time | date: '%s' -%}
{%- endif -%}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>그리고 이를 다른 <code class="language-plaintext highlighter-rouge">header</code> 문구가 있는 html 파일에 다음과 같이 적용한다.</p>

<div class="language-liquid highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="p">{%</span><span class="w"> </span><span class="nt">include</span><span class="w"> </span>build_versions.html<span class="w"> </span><span class="p">%}</span>

&lt;!-- 각종 css --&gt;
&lt;link
  rel="stylesheet"
  href="<span class="p">{{</span><span class="w"> </span><span class="s1">'assets/css/style.css'</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">relative_url</span><span class="w"> </span><span class="p">}}</span>?v=<span class="p">{{</span><span class="w"> </span><span class="nv">build_version</span><span class="w"> </span><span class="p">}}</span>"
/&gt;

&lt;!-- 각종 js --&gt;
&lt;script src="<span class="p">{{</span><span class="w"> </span><span class="s1">'assets/js/bundle.js'</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">relative_url</span><span class="w"> </span><span class="p">}}</span>?v=<span class="p">{{</span><span class="w"> </span><span class="nv">build_version</span><span class="w"> </span><span class="p">}}</span>"&gt;&lt;/script&gt;
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="github-actions로-jekyll-사이트를-빌드할-경우">Github Actions로 Jekyll 사이트를 빌드할 경우</h3>

<p>만약 깃허브 Actions로 빌드할 경우 기본적으로 Ubuntu 환경에서 빌드되며 jekyll의 환경에선 기본적으로 <a href="https://jekyllrb.com/docs/variables/#site-variables">site.time</a>에 build된 시간이 저장된다.</p>

<div class="language-liquid highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>&lt;link
  href="<span class="p">{{</span><span class="w"> </span><span class="s1">'assets/js/core.min.js'</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">relative_url</span><span class="w"> </span><span class="p">}}</span>?v=<span class="p">{{</span><span class="w"> </span><span class="nv">site</span><span class="p">.</span><span class="nv">time</span><span class="w"> </span><span class="p">|</span><span class="w"> </span><span class="nf">date</span><span class="p">:</span><span class="w"> </span><span class="s1">'%s'</span><span class="w"> </span><span class="p">}}</span>"
  rel="stylesheet"
/&gt;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이처럼 에셋을 가져오는 문구의 href 마지막에 <code class="language-plaintext highlighter-rouge">?v={{ site.time | date: '%s' }}</code> 를 붙이면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">%s</code>는 기본적으로 date의 <strong>strftime 필터를 가져오며</strong> <code class="language-plaintext highlighter-rouge">1970-01-01 00:00:00 UTC.</code> 이후로 지난 초 형식으로 변환한다.</p>

<p><br /></p>

<blockquote>
  <p>이제부터 잘 갱신되는 블로그와 행복한 나날을 보내자!</p>
</blockquote>

<hr />

<h3 id="참조">참조</h3>

<p><a href="https://stalker5217.github.io/javascript/cache/">https://stalker5217.github.io/javascript/cache/</a></p>

<p><a href="https://milanaryal.com.np/jekyll-static-assets-cache-busting/">https://milanaryal.com.np/jekyll-static-assets-cache-busting/</a></p>]]></content><author><name></name></author><category term="개발" /><category term="블로그" /><category term="Jekyll" /><category term="캐시" /><category term="캐시중지" /><category term="캐시비활성화" /><category term="자동삭제" /><category term="캐시삭제" /><category term="예찬군" /><summary type="html"><![CDATA[사이트 캐시 자동 삭제, 사이트 캐시 비활성화 방법, Jekyll 캐시 사용 중지]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://yechankun.github.io/assets/img/blog/cache_1_thumnail.png" /><media:content medium="image" url="https://yechankun.github.io/assets/img/blog/cache_1_thumnail.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">백준 랜선 자르기 풀이, 파이썬</title><link href="https://yechankun.github.io/posts/%EB%B0%B1%EC%A4%80-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0-%ED%92%80%EC%9D%B4,-%ED%8C%8C%EC%9D%B4%EC%8D%AC/" rel="alternate" type="text/html" title="백준 랜선 자르기 풀이, 파이썬" /><published>2023-04-22T23:52:00+09:00</published><updated>2023-04-22T23:52:00+09:00</updated><id>https://yechankun.github.io/posts/%EB%B0%B1%EC%A4%80-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0-%ED%92%80%EC%9D%B4,-%ED%8C%8C%EC%9D%B4%EC%8D%AC</id><content type="html" xml:base="https://yechankun.github.io/posts/%EB%B0%B1%EC%A4%80-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0-%ED%92%80%EC%9D%B4,-%ED%8C%8C%EC%9D%B4%EC%8D%AC/"><![CDATA[<h2 id="문제-출처"><strong>문제 출처</strong></h2>

<ul>
  <li>https://www.acmicpc.net/problem/1654</li>
</ul>

<h2 id="풀이-과정">풀이 과정</h2>

<ol>
  <li>이 문제는 이분탐색으로 풀 수 있다.</li>
  <li>N개보다 많이 잘라내는 값을 찾아야 하는데 더 이상 N개보다 더 많이 자를 수 있게 되면 start를 +1 시킨다.</li>
  <li>1씩 늘어나므로 end와 같아지게 되면 그것이 최대 길이가 된다.</li>
  <li>시간복잡도는 KlogN인데 N보다 많이 만들어도 되는 경우가 있기 때문에 근소한 차이가 있다.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>

<span class="n">K</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">readline</span><span class="p">().</span><span class="nf">split</span><span class="p">())</span>
<span class="n">lan</span> <span class="o">=</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">readline</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>

<span class="n">start</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">end</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">lan</span><span class="p">)</span>

<span class="k">while</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lan</span><span class="p">:</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="n">l</span> <span class="o">//</span> <span class="n">mid</span>
    <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>

<span class="nf">print</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name></name></author><category term="알고리즘" /><category term="백준" /><category term="니체" /><category term="예찬군" /><category term="알고리즘" /><category term="랜선" /><category term="자르기" /><category term="파이썬" /><category term="Python" /><summary type="html"><![CDATA[문제 출처]]></summary></entry><entry><title type="html">WebSocket 챕터 #2: 웹소켓 프로토콜</title><link href="https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-2-%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/" rel="alternate" type="text/html" title="WebSocket 챕터 #2: 웹소켓 프로토콜" /><published>2023-04-21T20:03:00+09:00</published><updated>2023-04-23T12:02:21+09:00</updated><id>https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-#2-%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C</id><content type="html" xml:base="https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-2-%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/"><![CDATA[<h2 id="웹소켓-프로토콜-websocket-protocol">웹소켓 프로토콜 (WebSocket Protocol)</h2>

<p><strong>WebSocket wire protocol (RFC 6455)</strong></p>

<ul>
  <li>HyBi 워킹 그룹에서 개발</li>
  <li>상위 구성 요소 (2가지)
    <ul>
      <li>연결 매개변수를 협상하는 데 사용되는 오프닝 HTTP 핸드셰이크 메커니즘</li>
      <li>텍스트 및 바이너리 데이터의 낮은 오버헤드, 메시지 기반 전송을 가능하게 하는 바이너리 메시지 프레임 메커니즘</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>웹소켓 프로토콜은 기존 양방향 HTTP 기술의 목표를 해결하려고 시도하며, 따라서 HTTP 포트 80 및 443에서 작동하도록 설계되었습니다.
하지만 웹소켓은 HTTP로 제한하지 않습니다. 때문에 전용 포트 사용하기도 가능하고 더 간단한 핸드셰이크를 사용할 수도 있습니다.</p>
</blockquote>

<p><em>WebSocket Protocol, RFC 6455</em></p>

<p>웹소켓 프로토콜은 <code class="language-plaintext highlighter-rouge">브라우저 외부</code>에서 사용할 수 있는 <code class="language-plaintext highlighter-rouge">독립형 프로토콜</code>입니다.</p>

<h3 id="이진-프레이밍-레이어-binary-framing-layer">이진 프레이밍 레이어 (Binary Framing Layer)</h3>

<ul>
  <li>발신자
    <ul>
      <li>임의의 UTF-8 또는 바이너리 페이로드를 제공합니다.</li>
    </ul>
  </li>
  <li>수신자
    <ul>
      <li>전체 메시지를 사용할 수 있을 때 알림 받습니다.</li>
    </ul>
  </li>
  <li>이를 위해 WebSocket은 사용자 지정 바이너리 프레임 형식(참조 1)을 사용<br />
애플리케이션 메시지를 하나 이상의 프레임으로 분할하고, 이를 대상으로 전송하고, 재조립한 후 전체 메시지가 수신되면 수신자에게 최종적으로 알립니다.<br />
웹소켓 통신은 이와 같은 프레임들을 교환하며 이루어집니다.</li>
</ul>

<p><img src="/assets/img/develop/websocket/2_1.png" alt="참조1" />
<em>참조 1. WebSocket의 어플리케이션 메시지 프레임 구조</em></p>

<p><strong>Frame (프레임)</strong></p>

<p>가변 길이의 프레임 헤더와 메시지를 일부나 전부 전달할 수 있는 페이로드를 포함하는 가장 작은 통신 단위.</p>

<p><strong>Message (메시지)</strong></p>

<p>논리적 애플리케이션 메시지에 매핑되는 프레임들을 합친 것</p>

<p><strong>어플리케이션 메시지 프레이밍</strong></p>

<ul>
  <li>메시지가 쪼개져서 프레임 단위가 되는 것을 의미함</li>
  <li>애플리케이션 메시지를 여러 프레임으로 분할할지 여부
    <ul>
      <li>클라이언트 및 서버 프레이밍 코드의 기본 구현에 의해 결정</li>
      <li>+) 여기서 말하는 프레이밍은 MTU와 같은 것으로 쪼개지는 프레이밍이 아님<a href="https://theamiableapi.com/2012/04/01/message-framing-in-rest/">https://theamiableapi.com/2012/04/01/message-framing-in-rest/</a></li>
    </ul>
  </li>
  <li>애플리케이션은 개별 웹소켓 프레임이나 프레이밍이 수행되는 방식을 알지 못함
    <ul>
      <li>하지만 각 웹소켓 프레임이 와이어에서 어떻게 표현되는지 주요 내용을 이해하는 것은 여전히 유용</li>
    </ul>
  </li>
  <li>각 프레임의 첫번째 비트(<code class="language-plaintext highlighter-rouge">FIN</code>) = 메시지 최종조각 여부
    <ul>
      <li>메시지는 단 하나의 프레임으로 구성될 수 있음</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Opcode</code>(4비트) = 전송된 프레임의 유형, 제어프레임
    <ul>
      <li>애플리케이션 데이터 전송을 위한 텍스트(1)</li>
      <li>바이너리(2)</li>
      <li>연결 상태 확인을 위한 연결 닫기(8)</li>
      <li>핑(9)</li>
      <li>퐁(10)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">마스크 비트</code>
    <ul>
      <li>페이로드의 마스크 여부를 나타냄</li>
      <li>마스크란 보안 기술로 개인을 식별할 수 있는 데이터를 보이지 않게 처리하는 것
        <ul>
          <li>여기서 페이로드 마스킹은 특히 웹소켓 프로토콜에서 중간자 공격(Man-in-the-Middle Attack)을 방지하기 위해 탄생함</li>
          <li><a href="https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">https://developer.mozilla.org/ko/docs/Web/API/WebSockets_API/Writing_WebSocket_servers</a></li>
          <li>위 글과 같이 손쉽게 마스킹된 페이로드를 디코딩 가능하지함</li>
        </ul>
      </li>
      <li>페이로드 마스킹의 목적
        <ul>
          <li>데이터 패킷의 패턴을 숨기고 위해 있음</li>
          <li>프록시 서버와 같은 중간자가 트래픽을 분석하고 패턴을 찾는 것을 막기 위함임. (연산비용이 높음)</li>
          <li>기본적인 방어책임, 데이터 보안 수준을 높이기 위한 완벽한 해결책 x</li>
        </ul>
      </li>
      <li>클라이언트에서 서버로 전송되는 메시지에만 해당</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">페이로드 길이</code> (마스크 비트를 빼고 7비트로 표시, 또한 가변 길이 필드로 표시)
    <ul>
      <li>0-125면 페이로드 길이를 뜻함</li>
      <li>126이면 다음 2바이트가 프레임 길이를 나타내는 16비트 부호 없는 정수</li>
      <li>127이면 다음 8바이트가 프레임 길이를 나타내는 64비트 부호 없는 정수</li>
      <li>즉 7bit의 페이로드 길이 값에 따라 그림 1의 Extended length를 얼마나 쓸지를 정함</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">마스킹 키</code>
    <ul>
      <li>페이로드를 마스킹하는 데 사용되는 32비트 값이 포함
        <blockquote>
          <p>모든 클라이언트에서 페이로드가 마스킹 되는 것은 캐시 포이즈닝 공격(<em>cache poisoning attack)</em>을 방지할 수 있음. 공격에 대한 자세한 내용은 W2SP 2011에서 발표된 <a href="http://w2spconf.com/2011/papers/websocket.pdf">“Talking to Yourself for Fun and Profit”</a>를 참조하세요.
해당 내용이 난해하다면 이 <a href="https://jusths.tistory.com/250">블로그의 게시글</a>도 확인해보세요.</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">페이로드</code>
    <ul>
      <li>연결이 설정될 때 클라이언트와 서버가 확장자를 협상한 경우 애플리케이션 데이터와 사용자 지정 확장자 데이터가 포함</li>
    </ul>
  </li>
</ul>

<p>결과적으로 각 웹소켓 프레임에는 <code class="language-plaintext highlighter-rouge">2~10바이트의 프레임 오버헤드</code>가 발생.</p>

<p>클라이언트는 웬만하면 항상 마스킹 키를 전송해야 하고 헤더에 4바이트가 추가되어 <code class="language-plaintext highlighter-rouge">6~14바이트의 오버헤드</code>가 발생.
이 오버헤드들은 모두 트래픽과 대역폭 제한에 영향을 줌</p>

<ul>
  <li>WebSocket Multiplexing과 Head-of-Line Blocking
메시지는 하나 이상의 프레임으로 분할될 수 있기 때문에 웹소켓은 head-of-line blocking에 취약.
HTTP/2 프레이밍 메커니즘에 “stream ID”에 해당하는 것이 없기 때문에 서로 다른 메시지의 프레임은 인터리빙(끼워넣기) 안됨 (<a href="https://hpbn.co/http2/#streams-messages-and-frames">Streams, Messages, and Frames</a> 참조)
대용량 메시지는 여러 개의 웹소켓 프레임으로 분할되어 있더라도 다른 메시지와 관련된 프레임의 전송을 차단합니다.
-&gt; 애플리케이션이 지연 시간에 민감한 데이터를 전송하는 경우 주의 필요. 메시지 분할 등을 활용
HyBi 워킹 그룹에서 개발한 새로운 “웹소켓용 멀티플렉싱 확장”
    <blockquote>
      <p>이 확장 기능을 사용하면 하나의 TCP 연결이 채널 ID로 태그된 프레임을 캡슐화하여 여러 개의 가상 웹소켓 연결을 제공할 수 있습니다… 멀티플렉싱 확장 기능은 별도의 논리 채널을 유지하며, 각 채널은 별도의 핸드셰이크 헤더를 포함하여 독립적인 웹소켓 연결과 논리적으로 완전히 동등한 기능을 제공합니다.
<em>WebSocket Multiplexing (Draft 10)</em>
이 확장 기능(HTTP/1 용)을 사용하면 동일한 TCP 연결을 통해 여러 웹소켓 연결(채널)을 멀티플렉싱할 수 있음.
HTTP/2는 스트림 멀티플렉싱이 내장되어 있고 HTTP/2 프레이밍 메커니즘 내에서 웹소켓 프레임을 캡슐화하여 단일 세션 내에서 여러 개의 웹소켓 연결을 전송할 수 있습니다.
HTTP/2에서의 WebSocket은 <a href="https://www.rfc-editor.org/rfc/rfc8441">RFC 8441</a>에 정의되어 있습니다.
<strong>결론: HTTP/2가 웹소켓 사양에서 고려할 것이 적다.</strong></p>
    </blockquote>
  </li>
</ul>

<h3 id="프로토콜-확장-protocol-extension">프로토콜 확장 (Protocol Extension)</h3>

<ul>
  <li>WebSocket은 프로토콜 확장을 허용함</li>
  <li>연결 포맷과 의미는 새로운 연산 코드와 데이터 필드로 확장 가능.</li>
  <li>클라이언트와 서버가 애플리케이션 코드 없이 기본 웹소켓 프레이밍 계층 위에 추가 기능 구현 가능</li>
  <li>클라이언트는 초기 업그레이드 핸드셰이크에서 확장 활성 여부를 알리고 서버는 협상된 연결의 수명 동안 사용할 확장을 선택하고 승인해야 함</li>
</ul>

<p>대신 웹소켓에서 <code class="language-plaintext highlighter-rouge">헤더 필드</code>나 <code class="language-plaintext highlighter-rouge">페이로드에 대한 기타 정보</code>와 같은 다른 메타데이터는 <code class="language-plaintext highlighter-rouge">사용할 수 없습니다.</code></p>

<p>WebSocket 프로코콜 확장의 예(By HyBi Working Group)</p>

<ul>
  <li><strong>A Multiplexing Extension for WebSockets</strong>
    <ul>
      <li>별도의 논리적 웹소켓 연결이 기본 전송 연결을 공유할 수 있는 방법 제공.</li>
    </ul>
  </li>
</ul>

<p>각 웹소켓 연결에는 전용 TCP 연결이 필요하므로 비효율적이기에 이 확장은 각 웹소켓 프레임에 “channel ID”를 추가하여 여러 가상 웹소켓 채널이 단일 TCP 연결을 공유해 해결합니다.</p>

<ul>
  <li><strong>Compression Extensions for WebSocket</strong>
    <ul>
      <li>웹소켓 프로토콜에 압축 기능을 추가하는 웹소켓 확장을 만들기 위한 프레임워크</li>
    </ul>
  </li>
</ul>

<p>과거에 기본 웹소켓 사양은 전송된 데이터의 압축을 위한 메커니즘이나 조항을 제공하지 않았을 때 제공되었던 확장입니다. 각 프레임은 애플리케이션에서 제공하는 페이로드 데이터를 전달합니다. 바이트 전송에서 압축 기술이 적용되지 않아 전송 오버헤드가 발생했고 압축 확장은 HTTP에서 제공하는 전송-인코딩 협상과 비슷합니다.</p>

<ul>
  <li>웹소켓 멀티플렉싱과 RFC 7692
HTTP/2 가 도입되면서 대부분의 브라우저가 웹소켓 멀티플렉싱을 지원합니다.
이 글의 원본이 적혔던 2013년에서 2년이 지난 2015년 12월 <a href="https://www.rfc-editor.org/rfc/rfc7692">RFC 7692</a>가 제정되어 WebSocket 프로토콜의 압축 통신에 대한 사양이 기술되었습니다.
프레임별 압축은 페이로드 콘텐츠를 프레임 단위로 압축하므로 여러 프리엠으로 분할될 수 있는 대용량 메시지에는 적합하지 않습니다. 따라서 RFC 7692에선 메시지별 압축을 적용하는 방식에 대해 기술하고 있으며 Deflate 알고리즘을 이용한 압축을 설명하고 있습니다.
현재 다양한 websocket 라이브러리들이 이를 지원하고 있고 이를 활성화 하면 웹소켓으로 발생하는 트래픽의 80% 가량을 절감할 수 있다고 <a href="https://websockets.readthedocs.io/en/stable/topics/compression.html">한 라이브러리</a>에서 설명하고 있습니다.</li>
</ul>

<h3 id="http-업그레이드-협상http-upgrade-negotiation">HTTP 업그레이드 협상(<strong>HTTP Upgrade Negotiation)</strong></h3>

<p>WebSocket protocol</p>

<ul>
  <li>메시지 지향 통신</li>
  <li>자체 바이너리 프레이밍 계층</li>
  <li>하위 프로토콜 협상</li>
  <li>선택적 프로토콜 확장</li>
</ul>

<p>웹소켓 프로토콜은 위와 같은 강력한 기능을 제공합니다.</p>

<p>하지만 메시지를 교환하기 전에 클라이언트와 서버는 연결을 설정하기 위해 적절한 매개변수로 협상해야 합니다.</p>

<p>HTTP를 활용하여 <code class="language-plaintext highlighter-rouge">Handshake</code>(핸드셰이크, 협상 과정)를 수행하면 아래와 같은 이점이 있습니다.</p>

<p>(처음에 얘기했듯 웹소켓은 HTTP 프로토콜에 한정되지 않습니다)</p>

<ol>
  <li>
    <p>기존 HTTP 인프라 호환</p>

    <p>웹소켓 서버는 클라이언트(브라우저)에서 유일하게 열려 있는 포트인 80번과 443번 포트에서 실행할 수 있습니다.</p>
  </li>
  <li>
    <p>협상을 수행하기 위해 커스텀 웹소켓 헤더를 사용하여 HTTP Upgrade 플로우를 재사용하고 확장할 수 있습니다.</p>
  </li>
</ol>

<p>아래는 협상을 위해 HTTP Upgrade 플로우에서 사용하는 매개변수들입니다.</p>

<p><code class="language-plaintext highlighter-rouge">Sec-WebSocket-Version</code></p>

<p>클라이언트가 사용하려는 웹소켓 프로토콜의 버전(RFC6455의 경우 “13”)을 나타냄.
서버가 이 버전을 지원하지 않으면 지원되는 버전 목록과 함께 응답.</p>

<p><code class="language-plaintext highlighter-rouge">Sec-WebSocket-Key</code></p>

<p>클라이언트가 전송하는 자동 생성 키.
서버가 요청된 버전의 프로토콜을 지원한다는 것을 증명하기 위해 서버에 호환성 검증 요청.</p>

<p><code class="language-plaintext highlighter-rouge">Sec-WebSocket-Accept</code></p>

<p>Sec-WebSocket-Key의 서명된 값을 포함함.</p>

<p>요청된 프로토콜 버전을 이해하고 있음을 증명하는 서버 응답임.</p>

<p><code class="language-plaintext highlighter-rouge">Sec-WebSocket-Protocol</code></p>

<p>애플리케이션 하위 프로토콜을 협상하는 데 사용.</p>

<p>클라이언트는 지원되는 프로토콜 목록을 알리고 서버는 단일 프로토콜 이름으로 응답함.</p>

<p><code class="language-plaintext highlighter-rouge">Sec-WebSocket-Extensions</code></p>

<p>웹소켓 확장을 사용할지 여부를 협상할 때 사용
클라이언트는 지원되는 확장을 알리고 서버는 동일한 헤더를 반환하여 사용할 리스트를 확인함.</p>

<p><strong>HTTP을 웹소켓으로 업그레이드 하는 클라이언트 요청</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="n">GET</span><span class="w"> </span><span class="nx">/socket</span><span class="w"> </span><span class="nx">HTTP/1.1</span><span class="w">
</span><span class="n">Host:</span><span class="w"> </span><span class="nx">server.example.com</span><span class="w">
</span><span class="n">Connection:</span><span class="w"> </span><span class="nx">Upgrade</span><span class="w">                                                     </span><span class="c">#1</span><span class="w">
</span><span class="n">Upgrade:</span><span class="w"> </span><span class="nx">websocket</span><span class="w">                                                      </span><span class="c">#2</span><span class="w">
</span><span class="n">Sec-WebSocket-Key:</span><span class="w"> </span><span class="nx">eGsdHGKsxBFSzDBe23djsS</span><span class="o">==</span><span class="w">                             </span><span class="c">#3</span><span class="w">
</span><span class="n">Sec-WebSocket-Protocol:</span><span class="w"> </span><span class="nx">chat</span><span class="p">,</span><span class="w"> </span><span class="nx">multichat</span><span class="w">                                 </span><span class="c">#4</span><span class="w">
</span><span class="n">Sec-WebSocket-Version:</span><span class="w"> </span><span class="nx">13</span><span class="w">                                               </span><span class="c">#5</span><span class="w">
</span><span class="n">Sec-WebSocket-Extensions:</span><span class="w"> </span><span class="nx">x-custom-extension1</span><span class="p">,</span><span class="w"> </span><span class="nx">x-custom-extension1</span><span class="w">      </span><span class="c">#6</span><span class="w">
</span><span class="n">Origin:</span><span class="w"> </span><span class="nx">http://example.com</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>서버에 다른 프로토콜로 변경 요청</li>
  <li>웹소켓 프로토콜로 업그레이드 요청</li>
  <li>서버 프로토콜 지원 확인을 위한 자동 생성 키</li>
  <li>애플리케이션에서 지정한 하위 프로토콜의 선택적 목록</li>
  <li>클라이언트에서 사용하는 웹소켓 프로토콜 버전</li>
  <li>클라이언트가 지원하는 프로토콜 확장 목록(선택 사항)</li>
</ol>

<p>(위는 순서대로 적용되는 것이 아닙니다)</p>

<p>웹소켓 요청에는 same-origin 정책이 적용됩니다.</p>

<p>브라우저는 upgrade 핸드셰이크에 origin 헤더를 추가하고 원격 서버는 CORS를 사용해 요청을 수락하거나 거부할 수 있습니다(<a href="https://hpbn.co/xmlhttprequest/#cross-origin-resource-sharing-cors">Cross-Origin Resource Sharing (CORS)</a> 참조).</p>

<p><strong>서버저가 클라이언트에 웹소켓으로 전환 됐음을 알리는 응답</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="n">HTTP/1.1</span><span class="w"> </span><span class="nx">101</span><span class="w"> </span><span class="nx">Switching</span><span class="w"> </span><span class="nx">Protocols</span><span class="w">                    </span><span class="c">#1</span><span class="w">
</span><span class="n">Connection:</span><span class="w"> </span><span class="nx">Upgrade</span><span class="w">                                 </span><span class="c">#2</span><span class="w">
</span><span class="n">Upgrade:</span><span class="w"> </span><span class="nx">websocket</span><span class="w">                                  </span><span class="c">#3</span><span class="w">
</span><span class="n">Access-Control-Allow-Origin:</span><span class="w"> </span><span class="nx">http://example.com</span><span class="w">     </span><span class="c">#4</span><span class="w">
</span><span class="n">Sec-WebSocket-Accept:</span><span class="w"> </span><span class="nx">eFdPsjqiIjqh73FJAlzEsd</span><span class="o">=</span><span class="n">AKao</span><span class="o">=</span><span class="w">  </span><span class="c">#5</span><span class="w">
</span><span class="n">Sec-WebSocket-Protocol:</span><span class="w"> </span><span class="nx">multichat</span><span class="w">                   </span><span class="c">#6</span><span class="w">
</span><span class="n">Sec-WebSocket-Extensions:</span><span class="w"> </span><span class="nx">x-custom-extension1</span><span class="w">       </span><span class="c">#7</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>웹소켓 업그레이드를 확인하는 101 응답 코드</li>
  <li>클라이언트에 연결이 다른 프로토콜로 변경됨을 알림</li>
  <li>웹소켓 프로토콜로 업그레이드 요청</li>
  <li>교차 출처 연결에 대한 옵트인(opt-in)을 나타내는 CORS 헤더</li>
  <li>서명된 키 값 증명 프로토콜 지원</li>
  <li>서버가 선택한 애플리케이션 하위 프로토콜</li>
  <li>서버가 선택한 웹소켓 확장 목록(없을 수 있음)</li>
</ol>

<p>모든 RFC6455 기반 웹소켓 서버는 동일한 방식으로 클라이언트의 호환성 검증 요청에 응답을 생성합니다. 서버는 Sec-WebSocket-Key 값을 표준에서 명시된 고유 GUID 문자열과 결합하여 SHA1 해시를 계산하고, 그 결과를 Base-64로 인코딩하여 클라이언트에 반환합니다.</p>

<p>웹소켓 핸드셰이크를 성공적으로 수행하려면, 최소한 프로토콜 버전과 클라이언트가 전송한 자동 생성된 호환성 검증 값이 포함되어야 합니다.</p>

<p>또한, 선택한 프로토콜 버전을 확인하기 위해, 서버는 해시된 챌린지-응답이 포함된 101 HTTP 응답 코드를 전송해야 합니다.</p>

<p>핸드셰이크가 정상적으로 완료되면, 연결이 WebSocket 메시지 전송을 위한 양방향 통신 채널로 사용될 수 있습니다. 이 시점부터는 HTTP 프로토콜 대신 WebSocket 프로토콜이 사용됩니다.</p>

<h3 id="요청-및-응답-스트리밍">요청 및 응답 스트리밍</h3>

<p>웹소켓은 동일한 TCP 연결을 통해 양방향 통신을 허용하는 사양에 정의된 유일한 프로토콜입니다.</p>

<p>참조2는 여러 통신 전송 방식이 어떤 구조와 방향으로 통신하는지에 대한 시각화입니다.</p>

<p><img src="/assets/img/develop/websocket/2_2.png" alt="참조2" />
<em>참조 2. XHR과 SSE, WebSocket의 연결 플로우</em></p>

<ul>
  <li>XHR은 요청-응답(request-response) 통신의 ‘트랜잭션’에 최적화되어 있습니다.
클라이언트는 서버에 완전한 HTTP 요청을 전달하고, 서버는 완전한 형식의 응답으로 응답합니다. 요청 스트리밍은 지원되지 않으며, 스트림 API가 도입되기 전에는 신뢰할 수 있는 브라우저 간 응답 스트리밍 API도 존재하지 않았습니다. XMLHttpRequest, fetch API, Axios와 같은 방식들이 REST API 요청에 사용되며, 이들은 모두 polling 방식의 요청 구조를 구현할 수 있습니다.</li>
  <li>SSE를 사용하면 텍스트 기반 데이터의 효율적이고 지연 시간이 짧은 서버 간 스트리밍이 가능합니다.
클라이언트가 SSE 연결을 시작하고 서버는 이벤트 소스 프로토콜을 사용하여 업데이트를 클라이언트로 스트리밍합니다.
클라이언트는 초기 핸드셰이크 이후에는 서버에 어떠한 데이터도 전송할 수 없습니다.</li>
  <li>웹소켓은 클라이언트와 서버 간의 양방향 통신을 가능하게 하는 프로토콜입니다.
앞서 말했듯 텍스트와 바이너리 데이터를 실시간으로 송수신할 수 있습니다.
웹소켓은 초기 핸드셰이크를 통해 연결이 수립되며, 이후에는 지속적인 연결을 통해 데이터를 주고받습니다. 그 결과, 웹소켓은 빠른 데이터 교환과 낮은 지연 시간을 제공하며, 서버와 클라이언트 간의 상호 작용이 필요한 실시간 애플리케이션에 적합합니다.</li>
  <li>하지만 위 모두 전파 속도와 서버의 큐 대기시간에 종속적인 부분이 있습니다.</li>
</ul>

<h3 id="메시지-오버헤드">메시지 오버헤드</h3>

<p>웹소켓으로 통신하는 메시지에는 오버헤드가 발생합니다.</p>

<p>애플리케이션 메시지</p>

<ul>
  <li>하나 이상의 프레임으로 분할.</li>
  <li>각 프레임은 2바이트에서 14바이트의 오버헤드를 추가.</li>
  <li>프레임은 사용자 정의 바이너리 형식을 통해 이루어지기 때문에 UTF-8 및 바이너리 애플리케이션 데이터 모두 동일한 메커니즘을 통해 효율적으로 인코딩 됨.</li>
</ul>

<p>WebScoket과 <strong>XHR 및 SSE와 비교</strong></p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>웹소켓 (WebSocket)</th>
      <th>XHR (XMLHttpRequest)</th>
      <th>SSE (Server-Sent Events)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>통신 방식</td>
      <td>양방향</td>
      <td>단방향 (요청-응답)</td>
      <td>단방향 (서버 → 클라이언트)</td>
    </tr>
    <tr>
      <td>메시지 형식</td>
      <td>텍스트, 바이너리</td>
      <td>텍스트, 바이너리</td>
      <td>텍스트</td>
    </tr>
    <tr>
      <td>프레임 구조</td>
      <td>간결한 바이너리 프레임</td>
      <td>풀 HTTP 헤더</td>
      <td>풀 HTTP 헤더</td>
    </tr>
    <tr>
      <td>지연 시간</td>
      <td>낮음</td>
      <td>중간</td>
      <td>중간</td>
    </tr>
    <tr>
      <td>연결 상태</td>
      <td>지속적</td>
      <td>각 요청마다 연결</td>
      <td>지속적</td>
    </tr>
    <tr>
      <td>전송 방식</td>
      <td>스트리밍</td>
      <td>요청-응답 기반</td>
      <td>스트리밍</td>
    </tr>
    <tr>
      <td>오버헤드</td>
      <td>최소 2바이트 ~ 최대 14바이트</td>
      <td>헤더 크기 (일반적으로 500바이트 ~ 2KB),<br /> 요청별 연결</td>
      <td>헤더 크기 (일반적으로 500바이트 ~ 2KB),<br /> 텍스트 전송만 가능</td>
    </tr>
    <tr>
      <td>상세 정보</td>
      <td>헤더 크기 최소화,<br /> 지속적 연결</td>
      <td>헤더 크기에 따른 높은 오버헤드,<br /> 요청별 연결</td>
      <td>헤더 크기에 따른 중간 오버헤드,<br /> 이벤트 기반</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>이 오버헤드에는 애플리케이션 프로토콜에 관계없이 메시지당 60~100바이트의 오버헤드를 추가하는 IP, TCP, TLS 프레이밍의 오버헤드가 포함되어 있지 않습니다. (<a href="https://hpbn.co/transport-layer-security-tls/#optimize-tls-record-size">Optimize TLS Record Size</a> 참조)</p>
</blockquote>

<h2 id="웹소켓-xhr-sse의-데이터-효율성-및-압축-비교"><strong>웹소켓, XHR, SSE의 데이터 효율성 및 압축 비교</strong></h2>

<p><strong>웹소켓 (WebSocket)</strong></p>

<p>웹소켓은 클라이언트와 서버 간의 양방향 통신을 효율적으로 처리하기 위해 설계되었습니다. 웹소켓의 데이터 효율성은 다음과 같은 방식으로 달성됩니다.</p>

<ol>
  <li>간결한 프레이밍: 웹소켓은 간결한 바이너리 프레이밍을 사용하여 메시지를 전송합니다. 이를 통해 웹소켓은 적은 양의 오버헤드로 메시지를 전송할 수 있습니다.</li>
  <li>지속적인 연결: 웹소켓은 클라이언트와 서버 간에 지속적인 연결을 유지하므로, 새로운 요청 및 응답을 위한 연결 생성 및 해제 비용이 절약됩니다.</li>
</ol>

<p>웹소켓은 ‘permessage-deflate’라는 확장을 사용하여 데이터 압축을 지원합니다. 이 확장을 사용하면 클라이언트와 서버는 압축된 데이터를 서로 주고받을 수 있습니다. 이를 통해 전송되는 데이터의 크기를 줄이고 대역폭을 절약할 수 있습니다.</p>

<p><strong>XHR (XMLHttpRequest)</strong></p>

<p>XHR은 요청-응답 통신 방식으로, 헤더를 전송하고 연결을 생성 및 해제하는 비용이 발생합니다. 이러한 특성 때문에 웹소켓에 비해 데이터 효율성이 떨어질 수 있습니다.</p>

<p>그러나 압축 측면에서는 XHR이 웹소켓과 유사한 성능을 제공합니다. XHR에서 전송되는 데이터는 HTTP 프로토콜에 의해 압축될 수 있습니다. 대표적인 HTTP 압축 방식으로는 gzip, deflate, brotli 등이 있습니다.</p>

<p><strong>SSE (Server-Sent Events)</strong></p>

<p>SSE는 서버에서 클라이언트로의 단방향 통신을 지원하며, 헤더 크기에 따른 오버헤드가 있습니다. SSE는 텍스트 기반 데이터 전송에 최적화되어 있으며, 연속적인 데이터 스트림에 적합합니다.</p>

<p>SSE에서 전송되는 데이터도 HTTP 프로토콜에 의해 압축될 수 있습니다. 따라서 XHR과 마찬가지로 SSE에서도 압축을 통해 데이터 크기를 줄이고 대역폭을 절약할 수 있습니다. SSE에서도 gzip, deflate, brotli 등의 HTTP 압축 방식을 사용할 수 있습니다.</p>

<blockquote>
  <p><strong>결론</strong></p>

  <p>각 통신 방식의 데이터 효율성 및 압축 성능은 사용 사례에 따라 선택할 수 있으며, 각 방식의 장점을 최대한 활용해야 합니다. 웹소켓은 지속적인 양방향 통신이 필요한 경우, XHR은 트랜잭션 요청-응답 통신이 필요한 경우, SSE는 서버에서 클라이언트로의 지속적인 데이터 전송이 필요한 경우에 적합합니다.</p>
</blockquote>

<h3 id="커스텀-애플리케이션-프로토콜custom-application-protocol">커스텀 애플리케이션 프로토콜(Custom Application Protocol)</h3>

<p>WebSocket은 기존의 HTTP 프로토콜과는 다른 양식을 가지며, 클라이언트와 서버 간에 사용자 지정된 프로토콜을 사용하여 데이터를 전송합니다. 이러한 이유로 WebSocket은 일종의 맞춤형 프로토콜로 간주되기도 합니다.</p>

<p>일반적으로, 스트리밍 서비스에서 WebSocket과 같은 프로토콜을 사용하면, 클라이언트와 서버 간에 실시간 양방향 통신을 제공할 수 있습니다. 이를 통해 더 높은 대역폭 사용률과 더 낮은 지연 시간을 제공할 수 있습니다. 또한, 맞춤형 프로토콜을 사용하면 데이터를 압축하거나, 메시지 전달을 최적화하거나, 세션 상태를 관리하는 등의 추가 기능을 구현할 수 있습니다.</p>

<p>그러나 WebRTC와 RTMP와 같은 다른 프로토콜도 사용될 수 있습니다. WebRTC는 실시간 비디오 및 오디오 통신을 위해 설계되었으며, P2P 통신 기술을 사용합니다. RTMP는 Adobe Flash 플레이어에서 사용되는 프로토콜로, 동영상 스트리밍에 사용됩니다.</p>

<p>브라우저는 HTTP 프로토콜에 최적화되어 있어서, XHR 요청과 같은 HTTP 기반의 요청에 대해서는 다양한 서비스를 제공합니다. 이러한 서비스에는 인증, 캐싱, 압축 등이 포함됩니다.</p>

<p>그러나 맞춤형 프로토콜을 사용하면 HTTP 프로토콜에서 제공되는 일부 서비스를 사용할 수 없다는 단점이 있습니다. 예를 들어, HTTP 캐시, 인증, 쿠키와 같은 서비스는 맞춤형 프로토콜에서 직접 구현해야 합니다.</p>

<blockquote>
  <p>웹소켓에서는 쿠키를 이용해서 초기의 핸드셰이크 연결 구성에서 사용자 인증을 진행할 수 있습니다.</p>
</blockquote>

<p><strong>WebSocket과 캐시 활용법</strong></p>

<p>웹소켓은 CDN 등에서 캐시를 하지 못합니다. 하지만 일반 HTTP 통신은 캐싱이 됩니다.</p>

<p>효율적인 캐싱 전략을 위해 웹소켓은 제어 명령을 통신하고 이 제어 명령으로 캐시된 데이터를 불러오게 요청하는 방법을 사용할 수 있습니다.</p>

<h3 id="웹소켓-인프라-배포-및-최적화-구성전략">웹소켓 인프라 배포 및 최적화 구성전략</h3>

<p>웹소켓은 실시간 양방향 통신을 가능하게 하는 효과적인 기술입니다. 웹소켓 인프라 배포를 성공적으로 수행하려면 몇 가지 주요 사항을 고려해야 합니다. 이 글에서는 웹소켓 인프라 배포를 최적화하고 구성하는 방법에 대해 설명합니다.</p>

<ol>
  <li>내부 네트워크 조정
내부 네트워크의 라우터, 로드 밸런서, 프록시를 적절하게 구성하고 조정해야 웹소켓 세션의 수명이 길어질 수 있습니다. 이를 통해 오래 지속되는 연결을 지원하고 성능을 개선할 수 있습니다.</li>
  <li>외부 네트워크 프록시 고려
외부 네트워크의 투명한 및 명시적인 프록시를 고려해야 합니다. 이를 해결하기 위해 TLS를 사용하여 웹소켓 트래픽을 안전하게 터널링할 수 있습니다. 이 방법은 중간 프록시를 우회할 수 있으며, 웹소켓 세션 협상의 성공률을 높이고 연결 시간 초과 간격을 연장하는 데 도움이 됩니다.</li>
  <li>클라이언트 네트워크 고려
클라이언트 네트워크의 라우터, 방화벽, 프록시를 고려해야 합니다. 일부 네트워크에서는 웹소켓 트래픽을 완전히 차단할 수 있으므로 대체 전략을 갖추는 것이 중요합니다.</li>
  <li>인프라 검토 및 사용자 지정 구성
인프라를 검토하고 필요한 경우 사용자 지정 구성을 적용해야 합니다. 예를 들어, Nginx 또는 HAProxy와 같은 서버, 프록시, 부하 분산 장치의 구성을 조정하여 오래 지속되는 연결을 지원할 수 있습니다.</li>
</ol>

<p>예를 들어, Nginx 를 이용한 구성을 보여드리겠습니다. 이 예제에서는 다음과 같은 구성 요소를 사용합니다.</p>

<ol>
  <li>업스트림 서버 정의 (Upstream Server Definition)</li>
  <li>로드 밸런싱 알고리즘 (Load Balancing Algorithm)</li>
  <li>프록시 설정 (Proxy Configuration)</li>
</ol>

<p>먼저 Nginx 설정 파일 (예: /etc/nginx/nginx.conf)에서 업스트림 서버를 정의합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>http <span class="o">{</span>
    upstream websocket_servers <span class="o">{</span>
        server backend1.example.com:8080<span class="p">;</span>
        server backend2.example.com:8080<span class="p">;</span>
    <span class="o">}</span>
    ...
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이 코드는 “websocket_servers”라는 이름의 업스트림 서버 그룹을 정의하며, 백엔드 서버 두 개를 포함합니다.</p>

<p>다음으로 로드 밸런싱 알고리즘을 선택합니다. Nginx에서 사용할 수 있는 로드 밸런싱 알고리즘 중 하나는 라운드 로빈입니다. 이 알고리즘은 기본적으로 사용되며, 추가 구성 없이 사용할 수 있습니다. 다른 알고리즘을 사용하려면 아래와 같이 설정합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>upstream websocket_servers <span class="o">{</span>
    least_conn<span class="p">;</span> <span class="c"># 최소 연결 알고리즘을 사용하려면 이 코드를 추가</span>
    ip_hash<span class="p">;</span>    <span class="c"># 세션 지속성을 위한 IP 해시 알고리즘을 사용하려면 이 코드를 추가</span>
    server backend1.example.com:8080<span class="p">;</span>
    server backend2.example.com:8080<span class="p">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>마지막으로 프록시 설정을 수행합니다. Nginx에서 웹소켓을 프록시하려면 HTTP/1.1 버전을 사용하고 필요한 헤더를 설정해야 합니다. 또한 타임아웃 값을 늘려 안정적인 연결을 보장할 수 있습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>server <span class="o">{</span>
    listen 80<span class="p">;</span>
    server_name example.com<span class="p">;</span>

    location /websocket <span class="o">{</span>
        proxy_pass http://websocket_servers<span class="p">;</span>
        proxy_http_version 1.1<span class="p">;</span>
        proxy_set_header Upgrade <span class="nv">$http_upgrade</span><span class="p">;</span>
        proxy_set_header Connection <span class="s2">"upgrade"</span><span class="p">;</span>
        proxy_read_timeout 3600s<span class="p">;</span>
        proxy_send_timeout 3600s<span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이 코드는 웹소켓 요청을 “websocket_servers” 업스트림 그룹으로 전달하도록 프록시 설정을 합니다. HTTP/1.1을 사용하고 “Upgrade” 및 “Connection” 헤더를 설정하여 웹소켓 핸드셰이크를 지원합니다. 마지막으로, 읽기 및 전송 타임아웃을 1시간 (3600초)으로 설정하여 오랫동안 연결이 유지되도록 합니다.</p>

<p>이 구성은 웹소켓 서비스에 고가용성과 확장성을 제공하며, 요청을 여러 백엔드 서버 간에 균등하게 분산시킵니다.또한 다음과 같은 이점이 있습니다.</p>

<ol>
  <li>고가용성: 한 서버에 문제가 발생하더라도 다른 서버가 요청을 처리하여 서비스가 지속됩니다.</li>
  <li>확장성: 백엔드 서버를 추가하거나 제거하여 트래픽 변화에 대응할 수 있습니다.</li>
  <li>성능 최적화: 로드 밸런싱 알고리즘을 사용하여 웹소켓 요청을 최적의 서버로 전달할 수 있습니다.</li>
</ol>

<p>물론, 웹소켓 인프라 배포를 위한 Nginx 프록시 및 로드 밸런싱 구성은 여러 가지 다른 요소에 따라 변경될 수 있습니다. 예를 들어, 보안을 강화하기 위해 SSL/TLS 설정을 추가할 수 있으며, 웹 애플리케이션 요구 사항에 맞게 다른 로드 밸런싱 알고리즘을 사용할 수 있습니다.</p>

<p>이 예제는 대부분의 인프라에서 오래 지속되는 세션을 처리하기 위해 사용자 지정 구성이 필요한 것을 보여주기 위한 것입니다. 따라서 애플리케이션에서 지속적인 연결을 구현하기 전에 인프라를 검토하는 것이 중요합니다.</p>

<p>장기간 지속되는 유휴 세션은 모든 중간 서버에서 메모리와 소켓 리소스를 소모합니다. 이로 인해 보안, 리소스 및 운영 측면에서 짧은 시간 제한을 설정하는 것이 합리적인 경우가 많습니다. 웹소켓, SSE, HTTP/2와 같이 긴 세션을 사용하는 기술을 도입하면 새로운 운영상의 문제가 발생할 수 있습니다.</p>

<p>요약하면, 웹소켓 인프라 배포를 최적화하려면 다음과 같은 사항을 고려해야 합니다:</p>

<ol>
  <li>내부 네트워크의 라우터, 로드 밸런서, 프록시를 조정합니다.</li>
  <li>외부 네트워크의 프록시를 고려하고 TLS를 사용하여 웹소켓 트래픽을 안전하게 터널링합니다.</li>
  <li>클라이언트 네트워크의 라우터, 방화벽, 프록시를 고려하고 대체 전략을 준비합니다.</li>
  <li>인프라를 적절하게 검토하고 필요한 경우 사용자 지정 구성을 적용합니다.</li>
</ol>

<p>이렇게 하면 웹소켓 인프라 배포를 효과적으로 관리하고 성능을 최적화할 수 있습니다.</p>

<h2 id="웹소켓-서비스-성능-향상을-위한-체크리스트"><strong>웹소켓 서비스 성능 향상을 위한 체크리스트</strong></h2>

<p>웹소켓 서비스의 성능을 향상시키기 위해 고려해야 할 주요 요소들은 다음과 같습니다:</p>

<ol>
  <li><strong>최신 웹소켓 라이브러리 사용</strong>: 보안과 성능 향상을 확보하기 위해 최신 버전의 웹소켓 라이브러리를 사용하세요. 이렇게 하면 기능 개선 및 버그 수정이 반영된 라이브러리를 활용할 수 있습니다.</li>
  <li><strong>보안 웹소켓 사용</strong>: 중간자 공격으로부터 데이터를 보호하기 위해 TLS를 통한 보안 웹소켓(WSS)을 사용하세요.</li>
  <li><strong>서버 성능 최적화</strong>: 서버의 메모리, CPU 사용량 및 네트워크 대역폭을 모니터링하고, 필요한 경우 서버 자원을 증가시켜 성능을 향상시키세요.</li>
  <li><strong>프로토콜 최적화</strong>: 데이터 전송을 최적화하기 위해 사용되는 프로토콜을 검토하고, 필요한 경우 최적의 프로토콜로 전환하세요.</li>
  <li><strong>커넥션 재사용</strong>: 가능한 경우 웹소켓 커넥션을 재사용하여, 커넥션 설정 및 해제 시 발생하는 오버헤드를 최소화하세요.</li>
  <li><strong>메시지 크기 최적화</strong>: 데이터를 압축하거나 필요한 데이터만 전송하도록 메시지 구조를 최적화하여 메시지 크기를 최소화하세요.</li>
  <li><strong>스트레스 테스트 및 성능 모니터링</strong>: 웹소켓 서비스에 대한 스트레스 테스트를 수행하고, 서비스의 성능을 지속적으로 모니터링하여 문제를 신속하게 파악하고 개선하세요.</li>
  <li><strong>폴리필 성능 주의</strong>: 필요한 경우 폴리필 성능에 주의를 기울여 호환성 문제를 해결하면서 성능 저하를 최소화하세요.</li>
  <li><strong>서브프로토콜 협상 활용</strong>: 애플리케이션 프로토콜을 결정하기 위해 서브프로토콜 협상을 활용하세요. 이를 통해 클라이언트와 서버 간에 효율적인 통신 방식을 선택할 수 있습니다.</li>
  <li><strong>클라이언트에서 버퍼링된 데이터량 모니터링</strong>: 클라이언트에서 버퍼링된 데이터량을 모니터링하여 데이터 전송 속도와 서버 측 처리 속도 간의 균형을 유지하세요. 이를 통해 클라이언트의 메모리 사용량을 최적화하고 애플리케이션 성능을 향상시킬 수 있습니다.</li>
  <li><strong>대용량 애플리케이션 메시지 분할</strong>: 대기열 차단을 피하기 위해 대용량 애플리케이션 메시지를 분할하세요. 이렇게 하면 큰 메시지가 전송되는 동안 다른 메시지들이 대기 상태에 빠지는 것을 방지할 수 있습니다.</li>
  <li><strong>이진 페이로드 최적화</strong>: 전송 크기를 최소화하기 위해 이진 페이로드를 최적화하세요. 이를 통해 데이터 전송 속도를 높이고, 네트워크 지연을 줄일 수 있습니다.</li>
  <li><strong>UTF-8 콘텐츠 압축 고려</strong>: 전송 크기를 최소화하기 위해 UTF-8 콘텐츠를 압축할 수 있는지 고려하세요. 이를 통해 텍스트 기반의 메시지 전송 효율을 높일 수 있습니다.</li>
  <li><strong>받은 이진 페이로드에 적절한 이진 타입 설정</strong>: 받은 이진 페이로드에 대해 적절한 이진 타입을 설정하여 데이터 처리 속도를 높이세요.</li>
</ol>

<p>이러한 요소들을 체크리스트로 만들어 성능 향상을 위한 지침으로 활용하면 웹소켓 서비스의 전반적인 성능을 개선할 수 있습니다. 또한 지속적인 모니터링과 최적화를 통해 서비스의 안정성과 확장성을 높일 수 있습니다.</p>

<p>또한 모바일 기기의 경우 배터리 최적화 문제를 신경써야할 수 있습니다. 물론 요즘 디바이스들은 충분한 배터리 용량을 가지고 있지만 그럼에도 이러한 고려는 생각해볼만 합니다.</p>

<p>다음의 타 저자의 게시글들을 확인해 보세요.</p>

<ul>
  <li><a href="https://hpbn.co/optimizing-for-mobile-networks/#preserve-battery-power">Preserve Battery Power</a></li>
  <li><a href="https://hpbn.co/optimizing-for-mobile-networks/#eliminate-periodic-and-inefficient-data-transfers">Eliminate Periodic and Inefficient Data Transfers</a></li>
  <li><a href="https://hpbn.co/optimizing-for-mobile-networks/#nagle-and-efficient-server-push">Nagle and Efficient Server Push</a></li>
  <li><a href="https://hpbn.co/optimizing-for-mobile-networks/#eliminate-unnecessary-application-keepalives">Eliminate Unnecessary Application Keepalives</a></li>
</ul>]]></content><author><name></name></author><category term="개발" /><category term="네트워크" /><category term="니체" /><category term="예찬군" /><category term="WebSocket" /><category term="socket" /><category term="웹소켓" /><category term="네트워크" /><category term="프로토콜" /><category term="protocol" /><summary type="html"><![CDATA[웹소켓 프로토콜 (WebSocket Protocol)]]></summary></entry><entry><title type="html">WebSocket 챕터 #1: 서론과 웹소켓 API</title><link href="https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/" rel="alternate" type="text/html" title="WebSocket 챕터 #1: 서론과 웹소켓 API" /><published>2023-04-17T09:03:00+09:00</published><updated>2023-04-23T11:41:41+09:00</updated><id>https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-#1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API</id><content type="html" xml:base="https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/"><![CDATA[<h2 id="웹소켓websocket-서론">웹소켓(WebSocket) 서론</h2>

<p>WebSocket은 브라우저와 서버 간의 양방향 메시지 전송을 가능하게 하는 프로토콜입니다. 웹소켓은 브라우저에서 사용할 수 있는 가장 효과적이고 유연한 통신 수단 중 하나로, 기존 HTTP 인프라와의 상호 운용성을 제공하며, 메시지 중심 통신 및 효율적인 메시지 프레이밍을 통해 클라이언트와 서버 간에 원활한 데이터 스트리밍이 가능합니다.</p>

<h3 id="주요-특징"><strong>주요 특징</strong></h3>

<ul>
  <li>연결 협상 및 동일 출처 정책 시행</li>
  <li>기존 HTTP 인프라와의 상호 운용성</li>
  <li>메시지 중심 통신 및 효율적인 메시지 프레이밍</li>
  <li>서브프로토콜 협상 및 확장성</li>
</ul>

<p>웹소켓은 간단한 JSON 페이로드부터 사용자 지정 바이너리 메시지 형식까지 클라이언트와 서버 간에 다양한 애플리케이션 프로토콜을 계층화하여 전달할 수 있습니다. 이를 통해 양쪽 모두 언제든지 데이터를 전송할 수 있습니다.</p>

<p>그러나 사용자 정의 프로토콜의 단점은 바로 사용자 정의라는 점입니다. 애플리케이션은 브라우저에서 제공하는 상태 관리, 압축, 캐싱 등의 기능을 고려해야 합니다.</p>

<p>웹소켓을 사용할 때 항상 설계상의 제약과 성능의 절충점이 존재합니다. 최상의 성능을 위해서는 각 프로토콜과 전송 방식의 강점을 활용하는 것이 중요합니다.</p>

<h3 id="결론"><strong>결론</strong></h3>

<p>웹소켓은 HTTP, XHR, 또는 SSE를 완전히 대체할 수는 없습니다. 오히려, 이 프로토콜들의 강점을 활용하여 웹 애플리케이션의 성능과 사용성을 최적화하는 것이 바람직합니다. 웹소켓은 강력한 통신 도구이지만, 제약 사항과 장단점을 고려하여 적절한 사용이 필요합니다.</p>

<p><em>웹소켓은 여러 표준의 집합으로, 웹소켓 API는 W3C에서 정의하고 웹소켓 프로토콜(RFC 6455)와 그 확장은 HyBi 워킹 그룹(IETF)에서 정의합니다.</em></p>

<h2 id="웹소켓-api-websocket-api">웹소켓 API (WebSocket API)</h2>

<p>브라우저에서 직접 제공하는 웹소켓 API는 매우 작고 간단합니다. <strong><em>연결 관리 및 메시지 처리의 모든 하위 수준 세부사항은 브라우저에서 처리</em></strong> 합니다. 웹소켓 리소스의 URI와 애플리케이션 콜백이 필요한데, 아래 예제에서 코드를 확인할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="c1">//1. 새 보안 웹소켓 연결(wss) 열기</span>
<span class="kd">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws://example.com/socket</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">//2. 웹소켓 연결이 설정될 때 호출되는 선택적 콜백</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ws</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">);</span> <span class="c1">//3. 클라이언트가 서버로 보내는 메시지</span>
<span class="p">};</span>

<span class="c1">//4. 서버에서 새 메시지를 보낼 때마다 호출되는 콜백 함수</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span> <span class="k">instanceof</span> <span class="nx">Blob</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">processBlob</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="c1">//5. 수신된 바이너리 메시지 처리 로직 호출</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">processText</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="c1">//6. 수신된 텍스트 메시지 처리 로직 호출</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//7. 연결 오류가 발생한 경우 호출되는 선택적 콜백</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="c1">//8. 연결이 종료될 때 호출되는 선택적 콜백</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onclose</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>EventSource API와 비슷한 경험을 제공하면서도 웹소켓은 더 다양한 기능을 지원합니다. 이러한 유사성은 웹소켓이 기존 API와 호환성을 유지하면서 확장성을 제공하기 위한 의도적인 설계입니다.</p>

<p>하지만 몇 가지 중요한 차이점이 있습니다.</p>

<ol>
  <li>웹소켓은 양방향 통신을 지원하며, 클라이언트와 서버가 서로 메시지를 주고받을 수 있습니다. 반면, EventSource는 서버에서 클라이언트로의 단방향 통신만 지원합니다.
그리고 그 과정에서 서로 다른 프로토콜을 사용합니다.(EventSource Protocol 과 WebSocket Protocol)</li>
  <li>웹소켓은 텍스트뿐만 아니라 바이너리 데이터도 전송할 수 있습니다. EventSource는 텍스트 데이터만 전송할 수 있습니다.</li>
  <li>WebSocket은 서브프로토콜을 정의할 수 있습니다. 클라이언트와 서버는 이런 사용자 지정 프로토콜을 사용하여 데이터를 주고받을 수 있습니다. 예를 들어, JSON, XML, 또는 protobuf와 같은 데이터 형식을 사용하여 데이터를 전송할 수 있습니다. 또한, 서브 프로토콜을 사용하면, 각각의 특화된 기능을 구현할 수 있습니다.</li>
</ol>

<p>추가적인 내용은 아래에서 알아보겠습니다.</p>

<details>
<summary>브라우저의 웹소켓 애뮬레이팅 (Emulating WebSocket In The Browser)</summary>
<div>
    <p>웹소켓 프로토콜은 클라이언트와 서버간 실시간 양방향 통신을 위한 프로토콜입니다. 최신 버전(v13)으로 발전해 모든 브라우저에서 지원되며, 브라우저 지원 상황은 <strong><a href="http://caniuse.com/websockets%EC%97%90%EC%84%9C">http://caniuse.com/websockets에서</a></strong> 확인 가능합니다.</p>

    <p>하지만, 일부 브라우저에서는 웹소켓을 지원하지 않는 경우가 있으므로, 이를 대비하여 에뮬레이션하는 라이브러리가 필요합니다. 하지만, 웹소켓 API를 에뮬레이션하는 라이브러리는 전송에 어려움이 있어 성능에 영향을 미치는 경우가 있습니다.</p>

    <p>이를 해결하기 위해 SockJS와 같은 라이브러리는 “seamless fallback”을 가능하게 합니다. 이는 브라우저에서 웹소켓을 지원하지 않는 경우, SockJS가 웹소켓 대신 다른 전송 방법을 사용하여 대체합니다. 이를 통해 브라우저 호환성을 보장하면서도 성능 문제를 해결할 수 있습니다.</p>

    <p>또한, Socket.IO와 같은 라이브러리는 고급 기능을 추가로 제공합니다. 이러한 라이브러리를 사용하면 실시간 프레임워크를 쉽게 구현할 수 있으며, 구현과 구성을 최적화하여 성능을 향상시킬 수 있습니다. 이러한 라이브러리는 이벤트 기반 프로그래밍 모델을 제공하여 클라이언트와 서버 간의 통신을 단순화하며, 클라이언트 측에서도 간편하게 구현할 수 있습니다.</p>

    <p>따라서, 웹소켓을 이용한 실시간 양방향 통신을 구현하려면 브라우저 호환성을 고려하고, 성능 문제를 해결하기 위해 에뮬레이션하는 라이브러리와 고급 기능을 제공하는 라이브러리를 적절히 선택하여 사용해야 합니다.최상의 성능을 얻기 위해 네이티브 웹소켓 인터페이스를 활용하고, 폴백 전송 성능을 최적화하여 전반적인 통신 성능을 향상시키세요.</p>

  </div>
</details>

<h3 id="ws와-wss-url-스키마-ws-and-wss-url-schemes">WS와 WSS URL 스키마 (WS and WSS URL Schemes)</h3>

<p>WebSocket 프로토콜은?</p>

<ul>
  <li>웹소켓 프로토콜은 IETF(Internet Engineering Task Force)의 HyBi Working Group에서 제정되었습니다.</li>
  <li>이 그룹은 브라우저와 서버 간 통신에서 발생하는 문제를 해결하고 최적화된 양방향 통신 채널을 구축하기 위해 웹소켓 프로토콜을 만들었습니다.</li>
  <li>웹소켓 프로토콜은 브라우저와 서버 간 최적화된 양방향 통신 채널을 구축하기 위해 HTTP 대신 자체 사용자 지정 스키마를 사용합니다.</li>
</ul>

<p><strong>웹소켓 프로토콜의 URL 스키마</strong></p>

<ul>
  <li>일반 텍스트 통신에는 ‘ws’를 사용합니다.</li>
  <li>암호화된 채널(TCP+TLS)이 필요한 경우에는 ‘wss’를 사용합니다.</li>
</ul>

<p><strong>웹소켓 프로토콜의 확장성</strong></p>

<ul>
  <li>브라우저 외부에서도 비 HTTP 교환을 통해 협상할 수 있도록 확장성을 제공합니다.</li>
  <li>하지만, 사용자 지정 체계에서는 웹소켓 세션을 설정하기 위한 대체 핸드셰이크 메커니즘에 대한 기존 표준이 없어 추가적인 작업이 필요합니다.</li>
</ul>

<blockquote>
  <p><strong>정리</strong>
웹소켓 프로토콜은 브라우저와 서버 간 최적화된 양방향 통신 채널을 제공하며, HTTP 대신 자체 사용자 지정 스키마를 사용합니다. 일반 텍스트 통신에는 ‘ws’를 사용하고, 암호화된 채널이 필요한 경우에는 ‘wss’를 사용합니다. 또한, 웹소켓은 브라우저 외부에서도 비 HTTP 교환을 통해 협상할 수 있도록 확장성을 제공하지만, 사용자 지정 체계에서는 추가적인 작업이 필요합니다.</p>
</blockquote>

<h3 id="텍스트-및-바이너리-데이터-수신-receiving-text-and-binary-data-by-websocket">텍스트 및 바이너리 데이터 수신 (<strong>Receiving Text and Binary Data By WebSocket)</strong></h3>

<p>웹소켓을 사용하여 텍스트와 바이너리 데이터를 효율적으로 전송하고 수신할 수 있습니다.</p>

<ol>
  <li><strong>메시지와 애플리케이션 코드 구성</strong>
    <ul>
      <li>웹소켓은 메시지와 애플리케이션 코드로 구성되어 사용자가 데이터의 버퍼링, 구문 분석 및 재구성에 대해 걱정할 필요가 없습니다.</li>
    </ul>
  </li>
  <li><strong>데이터 처리의 유연성</strong>
    <ul>
      <li>웹소켓은 텍스트와 바이너리 데이터 모두 처리할 수 있으며, 애플리케이션 페이로드에 대한 제약이나 가정을 두지 않습니다.</li>
    </ul>
  </li>
  <li><strong>페이로드 정보 추적</strong>
    <ul>
      <li>웹소켓 프로토콜은 메시지에 대한 두 가지 정보만 추적합니다.
        <ul>
          <li>페이로드 길이: 가변 길이 필드로서 메시지의 길이를 나타냅니다.</li>
          <li>페이로드 유형: UTF-8과 바이너리 전송을 구분하기 위한 정보를 포함합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>데이터 자동 변환 및 전달</strong>
    <ul>
      <li>브라우저가 새 메시지를 수신할 때, 텍스트 기반 데이터는 DOMString 객체로, 바이너리 데이터는 Blob 객체로 자동 변환된 다음 애플리케이션에 전달됩니다.</li>
    </ul>
  </li>
  <li>
    <p><strong>성능 최적화 옵션</strong></p>

    <ul>
      <li>수신된 바이너리 데이터를 Blob 대신 ArrayBuffer로 변환하도록 브라우저에 지시함으로써 데이터 처리를 더욱 효율적으로 수행할 수 있습니다.</li>
    </ul>

    <blockquote>
      <p>Blob이란?</p>

      <ul>
        <li>변경 불가능한 원시 데이터로 구성된 파일과 같은 객체이며 데이터를 수정할 필요가 없고 더 작은 덩어리로 분할할 필요가 없습니다.
          <ul>
            <li>예: 전체 Blob 객체를 이미지 태그에 전달할 수 있는 경우 최적의 형식(<a href="https://hpbn.co/xmlhttprequest/#downloading-data-with-xhr">XHR로 데이터 다운로드의 예</a> 참조)</li>
          </ul>
        </li>
        <li>반면에 바이너리 데이터에 추가 처리를 수행해야 하는 경우 ArrayBuffer가 더 적합할 수 있습니다.</li>
      </ul>
    </blockquote>
  </li>
</ol>

<p>아래는 성능 최적화 옵션을 사용한 예시입니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">ws://example.com/socket</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// 바이너리 메시지 수신 시 ArrayBuffer 변환 강제 수행</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">binaryType</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">arraybuffer</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">ws</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span> <span class="k">instanceof</span> <span class="nb">ArrayBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">processArrayBuffer</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">processText</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>User agents는 이 속성을 수신 바이너리 데이터를 처리하는 방법에 대한 힌트로 사용할 수 있습니다. 속성이 “blob”으로 설정되어 있으면 디스크에 스풀링(데이터를 채우는 것)하는 것이 안전하며, “arraybuffer”로 설정되어 있으면 데이터를 메모리에 보관하는 것이 더 효율적일 가능성이 높습니다.
물론 사용자 에이전트는 수신 데이터를 메모리에 보관할지 여부를 결정하기 위해 보다 미묘한 휴리스틱을 사용하도록 권장됩니다.</p>
</blockquote>

<p><em>The WebSocket API, W3C Candidate Recommendation</em></p>

<details>
<summary>자바스크립트를 이용한 웹소켓에서 받은 바이너리 데이터 디코딩</summary>
<div>

    <p>예시로 C로 작성된 구조체의 객체를 메시지로 받아 웹소켓에서 디코딩하는 과정을 설명합니다.</p>

    <p>먼저, 다음과 같은 C 스타일의 바이너리 데이터 구조를 고려해봅시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">personInfo</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 이렇게 할당되어 있다 가정합니다.</span>
<span class="k">struct</span> <span class="n">personInfo</span> <span class="n">person</span> <span class="o">=</span> <span class="p">{</span><span class="s">"John Doe"</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">180</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>이 구조체는 사람의 정보를 담고 있습니다. 이름은 20바이트의 문자 배열, 나이는 unsigned int 형식, 그리고 키는 float 형식으로 구성되어 있습니다.</p>

    <p>웹소켓에서 이벤트를 받으면 다음과 같이 처리할 수 있습니다. 다음 예시처럼 WebSocket은 브라우저 내에서 바이너리 데이터를 처리하는 데 필요한 도구를 애플리케이션에 제공합니다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="nx">websocket</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>

  <span class="c1">// TypedArray를 사용한 방식</span>
  <span class="kd">var</span> <span class="nx">nameView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">ageView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">heightView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Float32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// 출력: Name: John Doe, Age: 30, Height: 180.5</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
    <span class="dl">"</span><span class="s2">Name: </span><span class="dl">"</span> <span class="o">+</span>
      <span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">nameView</span><span class="p">)</span> <span class="o">+</span>
      <span class="dl">"</span><span class="s2">, Age: </span><span class="dl">"</span> <span class="o">+</span>
      <span class="nx">ageView</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
      <span class="dl">"</span><span class="s2">, Height: </span><span class="dl">"</span> <span class="o">+</span>
      <span class="nx">heightView</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">);</span>

  <span class="c1">// DataView를 사용한 방식</span>
  <span class="kd">var</span> <span class="nx">dataView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataView</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">+=</span> <span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="nx">dataView</span><span class="p">.</span><span class="nf">getUint8</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">age</span> <span class="o">=</span> <span class="nx">dataView</span><span class="p">.</span><span class="nf">getUint32</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">dataView</span><span class="p">.</span><span class="nf">getFloat32</span><span class="p">(</span><span class="mi">24</span><span class="p">);</span>

  <span class="c1">// 출력: Name: John Doe, Age: 30, Height: 180.5</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Name: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">, Age: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">age</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">, Height: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">height</span><span class="p">);</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>위의 예시에서 ArrayBuffer를 각각 TypedArray 방식과 DataView 방식으로 바이너리 데이터를 해독하고 있습니다.</p>

  </div>
</details>

<h3 id="websocket텍스트-바이너리-데이터-전송-sending-text-and-binary-data-with-websocket">WebSocket텍스트 바이너리 데이터 전송 (<strong>Sending Text and Binary Data with WebSocket)</strong></h3>

<p>WebSocket을 사용하면 클라이언트와 서버 간에 텍스트 및 바이너리 데이터를 쉽게 주고받을 수 있습니다. WebSocket 프로토콜은 TCP 연결을 통해 양방향 메시지 전달이 가능하게 합니다. 이를 구현하는 과정은 다음과 같습니다.</p>

<ol>
  <li>WebSocket API 사용 데이터
WebSocket API는 다음과 같은 데이터 유형을 지원합니다.
    <ul>
      <li>UTF-8 인코딩된 문자열</li>
      <li>바이너리 전송을 위한 ArrayBuffer, ArrayBufferView, Blob 객체</li>
    </ul>
  </li>
  <li>
    <p>WebSocket 연결 생성 및 데이터 전송
웹 애플리케이션에서 이미지 파일과 텍스트 메시지를 동시에 전송해야 한다고 가정해봅시다.<br />
이 경우 다음과 같이 WebSocket 연결을 생성하고 데이터를 전송할 수 있습니다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws://example.com/socket</span><span class="dl">'</span><span class="p">);</span>

    <span class="nx">ws</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// 텍스트 메시지 전송</span>
      <span class="nx">ws</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello!</span><span class="dl">"</span><span class="p">);</span>

      <span class="c1">// 바이너리 데이터 (예: 이미지 파일) 전송</span>
      <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>
      <span class="nx">ws</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="s2">```

</span></pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>send() 메서드 및 비동기 처리
send() 메서드는 비동기식으로 처리되며, 데이터는 클라이언트에 의해 큐에 대기됩니다.<br />
함수는 즉시 반환되므로 대용량 페이로드 전송 시 전송 완료 신호로 오해하지 않도록 주의해야 합니다.</li>
  <li>
    <p>데이터 양 모니터링
애플리케이션에서는 소켓의 bufferedAmount 속성을 사용하여 브라우저에서 대기 중인 데이터 양을 모니터링할 수 있습니다.<br />
bufferedAmount가 0인 경우에만 send 메서드를 호출하여 데이터를 전송하는 방식도 있습니다. 이렇게 함으로써, 소켓의 대기열에 너무 많은 데이터가 쌓이는 것을 예방할 수 있습니다.</p>

    <p>다음은 만약 시스템에 업데이트가 발생했다면 서버의 데이터 갱신을 bufferedAmount가 0일 때에만 send를 호출하는 간단한 예제 코드입니다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">ws://example.com</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">updateInterval</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// 1초마다 시스템 업데이트 체크</span>

<span class="kd">function</span> <span class="nf">checkUpdate</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 시스템 업데이트 체크 후 업데이트가 있을 경우, 서버에 전송</span>
  <span class="kd">var</span> <span class="nx">updateData</span> <span class="o">=</span> <span class="nf">getUpdateData</span><span class="p">();</span> <span class="c1">// 시스템 업데이트 데이터 가져오기</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">updateData</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">updateData</span><span class="p">));</span> <span class="c1">// 업데이트 데이터를 JSON 문자열로 변환하여 전송</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 일정 주기마다 시스템 업데이트 체크</span>
<span class="nf">setInterval</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">checkUpdate</span><span class="p">();</span>
<span class="p">},</span> <span class="nx">updateInterval</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>위 예제 코드에서 checkUpdate 함수는 일정 주기마다 시스템 업데이트를 체크합니다. 시스템 업데이트가 있을 경우, 해당 업데이트 데이터를 JSON 형태로 변환한 후, WebSocket을 사용하여 서버에 전송합니다.</p>

    <p>시스템은 옵저버 패턴 등을 활용해서 더욱 구조적으로 구성할 수도 있습니다.</p>

    <p>이렇게 함으로써, 소켓의 대기열에 데이터가 많이 쌓이는 것을 예방하고 HOL 차단 현상을 완화할 수 있습니다. HOL 차단 현상을 완전히 해결하는 것은 아니지만, HOL 차단 현상을 예방하거나 완화하는데에 도움을 줄 수 있습니다.</p>
  </li>
  <li>
    <p>Head of Line (HOL) 차단 현상 해결
전송을 최적화하려면 각 메시지 유형이 소켓에 대기열에 포함되는 방식과 시기에 세심한 주의를 기울여야 합니다. 이를 통해 Head of Line (HOL) 차단 현상을 해결할 수 있습니다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>- 메시지 유형별 대기열 사용: 각 메시지 유형에 대한 대기열을 따로 유지하여, 큰 데이터 덩어리가 전송될 때 작은 데이터 덩어리가 먼저 전송되는 현상을 막을 수 있습니다. 예를 들어, 문자열과 바이너리 데이터를 구분하여 따로 전송하는 것이 좋습니다.
- 작은 데이터 덩어리 우선 전송: 큰 데이터 덩어리가 전송될 때는 작은 데이터 덩어리를 먼저 전송하는 것이 좋습니다. 이를 위해서는 메시지 크기를 제한하거나, 메시지가 큰 경우에는 여러 개의 작은 데이터 덩어리로 분할하여 전송하는 방법을 사용할 수 있습니다.
- 프로토콜 수준에서 해결: WebSocket 프로토콜 자체에서 HOL 차단 현상을 해결하는 기능을 제공할 수 있습니다. 예를 들어, WebSocket 스펙의 중간에 데이터를 전송할 수 있는 형식인 "Continuation Frames"을 사용하는 것이 좋습니다. 이를 이용하면, 큰 데이터 덩어리를 여러 개의 작은 데이터 덩어리로 분할하여 전송할 수 있으며, 이를 받는 쪽에서는 이들을 조합하여 전체 데이터를 복원할 수 있습니다.
- bufferedAmount를 확인하면 HOL를 예방하는 것엔 도움이 됩니다. 하지만 위와 같은 방식을 사용해서 근본적으로 HOL의 문제를 해결하는 것이 좋습니다.
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ol>

<blockquote>
  <p>많은 애플리케이션은 제어 트래픽과 같은 우선순위가 높은 업데이트와 백그라운드 전송과 같은 우선순위가 낮은 업데이트 등 여러 클래스의 메시지를 생성합니다.</p>
</blockquote>

<p>전송을 최적화하려면 애플리케이션은 각 메시지 유형이 소켓에 대기열에 포함되는 방식과 시기에 세심한 주의를 기울여야 합니다!</p>

<blockquote>

</blockquote>

<h3 id="서브프로토콜-협상">서브프로토콜 협상</h3>

<p>WebSocket 프로토콜</p>

<ul>
  <li>웹소켓 프로토콜은 각 메시지의 형식에 대해 어떠한 가정도 하지 않습니다.
    <ul>
      <li>단일 비트는 메시지에 텍스트 또는 바이너리 데이터가 포함되어 있는지 여부를 추적해 클라이언트와 서버가 효율적으로 디코딩할 수 있도록 하지만 그렇지 않은 경우 메시지 내용은 불투명합니다.</li>
    </ul>
  </li>
  <li>각 요청과 응답의 HTTP 헤더를 통해 추가 메타데이터를 전달하는 HTTP 또는 XHR 요청과 달리 웹소켓 메시지에는 이와 동등한 메커니즘이 없습니다.</li>
  <li>메시지에 대한 추가 메타데이터가 필요한 경우 클라이언트와 서버가 이런 데이터를 전달하기 위해 자체 서브프로토콜을 구현해야 합니다.</li>
  <li>클라이언트와 서버는 고정된 메시지 형식에 미리 합의할 수 있습니다.
    <ul>
      <li>예를 들어, 모든 통신은 JSON 인코딩된 메시지 또는 사용자 정의 바이너리 형식을 통해 이루어지며 필요한 메시지 메타데이터는 인코딩된 구조의 일부 형식 사용합니다.</li>
    </ul>
  </li>
  <li>클라이언트와 서버가 서로 다른 데이터 유형을 전송해야 하는 경우 일관된 메시지 헤더를 구성해야 하며, 이를 통해 나머지 페이로드를 디코딩하기 위한 지침을 전달할 수 있습니다.</li>
  <li>텍스트 메시지와 바이너리 메시지를 혼합하여 페이로드와 메타데이터 정보를 전달할 수 있습니다.
    <ul>
      <li>예를 들어 텍스트 메시지로 HTTP 헤더에 해당하는 내용을 전달한 다음 바이너리 메시지로 애플리케이션 페이로드를 전달할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<p>웹소켓은 메시지의 유연성과 낮은 오버헤드를 제공하지만, 메시지 직렬화와 메타데이터 관리는 문제의 일부입니다. 서로 다른 클라이언트와 서버 간에 동기화를 유지하려면 프로토콜 협상이 필요합니다.</p>

<p>웹소켓은 <strong><code class="language-plaintext highlighter-rouge">서브프로토콜 협상 API</code></strong>를 제공하여 이 문제를 해결합니다. 클라이언트는 초기 연결 핸드셰이크를 통해 어떤 프로토콜을 지원하는지 서버에 알릴 수 있습니다.<br />
이를 통해 클라이언트와 서버는 동일한 프로토콜을 사용하고 메시지 형식 및 메타데이터의 구조를 미리 합의할 수 있습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">ws://example.com/socket</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span>
  <span class="dl">"</span><span class="s2">chat</span><span class="dl">"</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">notification</span><span class="dl">"</span><span class="p">,</span>
<span class="p">]);</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">socket</span><span class="p">.</span><span class="nx">protocol</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">chat</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 서버와 클라이언트가 합의한 'chat' 서브프로토콜에 따른 로직 수행</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if </span><span class="p">(</span><span class="nx">socket</span><span class="p">.</span><span class="nx">protocol</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">notification</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 서버와 클라이언트가 합의한 'notification' 서브프로토콜에 따른 로직 수행</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이 예시에서는 <strong><code class="language-plaintext highlighter-rouge">chat</code></strong>과 <strong><code class="language-plaintext highlighter-rouge">notification</code></strong> 두 가지 서브프로토콜을 WebSocket 생성자에 전달합니다. 클라이언트는 초기 핸드셰이크 중에 서버에게 이를 알리며, 서버는 클라이언트가 지정한 서브프로토콜 중 하나를 선택하여 응답합니다.</p>

<p>하위 프로토콜 협상이 성공하면 클라이언트에서 onopen 콜백이 실행되고 WebSocket 객체의 프로토콜 속성을 통해 선택한 프로토콜을 확인할 수 있습니다. 클라이언트와 서버는 이를 통해 메시지의 형식과 메타데이터 구조를 미리 합의할 수 있습니다.</p>

<p>서브프로토콜 이름은 애플리케이션에서 정의되며, 초기 핸드셰이크 중에 클라이언트가 서버에게 전송됩니다. 코어 웹소켓 API에는 서브프로토콜 이름에 대한 특별한 처리 방법이 없으며, 지정된 서브프로토콜은 애플리케이션 로직과 관련된 부분입니다.</p>

<blockquote>
  <p>선택적으로 onerror를 이용해서 협상에 실패했을 때의 동작을 추가할 수 있습니다.</p>
</blockquote>

<p>웹소켓 API를 사용하면 쉽게 웹소켓 연결을 관리하고 메시지를 처리할 수 있으며, 높은 유연성과 확장성을 제공합니다. 이를 통해 실시간 웹 애플리케이션 및 서비스에 최적화된 솔루션을 구현할 수 있습니다. 하지만 다음과 같은 유의사항도 있습니다.</p>

<ul>
  <li>웹소켓은 기본적으로 연결 지향형이며, 네트워크 지연이나 연결 손실의 영향을 받을 수 있습니다.</li>
  <li>웹소켓은 기본적으로 암호화되지 않음. 따라서 중요한 데이터를 전송할 때는 반드시 보안 웹소켓(wss)를 사용해야 합니다.</li>
  <li>웹소켓은 전통적인 HTTP 프로토콜과는 다르게 작동하므로, 프록시 서버나 방화벽 설정에 주의해야 합니다.
이러한 문제를 해결하기 위해 기존 인프라와 웹소켓이 함께 작동하도록 구성할 수 있습니다.</li>
</ul>

<p>웹소켓 API는 높은 성능과 실시간 통신 기능을 제공하는 동시에 간단한 인터페이스를 유지합니다. 이를 통해 개발자들은 웹소켓 기반의 다양한 애플리케이션과 서비스를 구축할 수 있으며, 사용자에게 뛰어난 경험을 제공할 수 있습니다. 그러나 이를 사용하기 위해서는 웹소켓의 특성과 제약 사항을 이해하고 적절한 설계 및 구현이 필요합니다.</p>

<p>다음에는 이러한 웹소켓 API가 구현되기 위해 정의된 <code class="language-plaintext highlighter-rouge">웹소켓 프로토콜</code>에 대해 알아보겠습니다.</p>]]></content><author><name></name></author><category term="개발" /><category term="네트워크" /><category term="니체" /><category term="예찬군" /><category term="WebSocket" /><category term="socket" /><category term="웹소켓" /><category term="네트워크" /><summary type="html"><![CDATA[웹소켓(WebSocket) 서론]]></summary></entry><entry><title type="html">프로그래머스 level3 입국심사 파이썬 풀이</title><link href="https://yechankun.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-level3-%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC/" rel="alternate" type="text/html" title="프로그래머스 level3 입국심사 파이썬 풀이" /><published>2022-06-26T14:59:00+09:00</published><updated>2022-06-26T14:59:00+09:00</updated><id>https://yechankun.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-level3-%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC</id><content type="html" xml:base="https://yechankun.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-level3-%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC/"><![CDATA[<h3 id="문제-설명"><strong>문제 설명</strong></h3>

<p>n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.</p>

<p>처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.</p>

<p>모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.</p>

<p>입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.</p>

<h3 id="제한사항">제한사항</h3>

<ul>
  <li>입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.</li>
  <li>각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.</li>
  <li>심사관은 1명 이상 100,000명 이하입니다.</li>
</ul>

<h3 id="입출력-예">입출력 예</h3>

<table>
  <thead>
    <tr>
      <th>n</th>
      <th>times</th>
      <th>return</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>6</td>
      <td>[7, 10]</td>
      <td>28</td>
    </tr>
  </tbody>
</table>

<h3 id="입출력-예-설명">입출력 예 설명</h3>

<p>가장 첫 두 사람은 바로 심사를 받으러 갑니다.</p>

<p>7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.</p>

<p>10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.</p>

<p>14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.</p>

<p>20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.</p>

<p><a href="http://hsin.hr/coci/archive/2012_2013/contest3_tasks.pdf">출처</a></p>

<blockquote>
  <p>본 문제의 저작권자는 프로그래머스가 아닙니다. 이 문제는 https://codeforces.com/blog/entry/967 의 라이센스에 의하여 공개되었습니다.</p>
</blockquote>

<p>※ 공지 - 2019년 9월 4일 문제에 새로운 테스트 케이스를 추가하였습니다. 도움을 주신 weaver9651 님께 감사드립니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="c1">#ax1 + (n-a)x2 + ... 가 최소값이 되게 하는 것
#수식으론 풀 수 없는 무한 항에 가까운 문제
#경사 하강법과 비슷한 방식을 사용할 수 있다. 이분 탐색
</span><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span>                    <span class="c1">#최소 시간
</span>    <span class="n">right</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>       <span class="c1">#최악 시간
</span>    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mid</span><span class="o">//</span><span class="n">x</span><span class="p">,</span> <span class="n">times</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이분 탐색으로 풀 수 있는 문제였습니다.
처음에 이분탐색을 어떻게 적용해야 할지를 몰라 결국 솔루션을 보게된 문제입니다. ㅠㅠ</p>]]></content><author><name></name></author><category term="알고리즘" /><category term="프로그래머스" /><category term="니체" /><category term="예찬군" /><category term="알고리즘" /><category term="프로그래머스" /><category term="이분탐색" /><category term="LEVEL3" /><summary type="html"><![CDATA[문제 설명]]></summary></entry><entry><title type="html">안드로이드앱-브래인매니저</title><link href="https://yechankun.github.io/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%95%B1-%EB%B8%8C%EB%9E%98%EC%9D%B8%EB%A7%A4%EB%8B%88%EC%A0%80/" rel="alternate" type="text/html" title="안드로이드앱-브래인매니저" /><published>2022-03-20T23:03:00+09:00</published><updated>2022-03-21T00:55:25+09:00</updated><id>https://yechankun.github.io/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%95%B1-%EB%B8%8C%EB%9E%98%EC%9D%B8%EB%A7%A4%EB%8B%88%EC%A0%80</id><content type="html" xml:base="https://yechankun.github.io/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%95%B1-%EB%B8%8C%EB%9E%98%EC%9D%B8%EB%A7%A4%EB%8B%88%EC%A0%80/"><![CDATA[<h2 id="neomindstdbrainmanager-프로젝트">NeoMindStd/BrainManager 프로젝트</h2>

<p><a href="https://github.com/NeoMindStd/BrainManager">깃허브 링크</a></p>

<h2 id="소개">소개</h2>

<p>사용자가 기억하고자 하는 내용(키워드)을 간격 반복 알고리즘으로 복습시간을 알람. 사용자가 해당 내용을 잊지 않게 하는 안드로이드 앱입니다.</p>

<p>기능이 약간 추상적일 수 있는데 간단히 소개하자면 사용자가 키워드를 입력하고 해당 키워드의 설명을 적어넣고 등록하면 그 키워드와 설명에 대한 문제를 알아서 생성해서 복습할 수 있도록 도와줍니다.</p>

<p>영어단어, 사람, 기술적인 배움 등등 온갖 외워야 할 것들을 쉽게 외울 수 있도록 도와주는 것입니다!</p>

<p>구현을 하면서 가중치를 업데이트 하는 방식의 알고리즘을 사용했는데 문제의 정답률에 따라서 복습을 최적화 하는 등의 기능을 추가로 구현해볼 수 있을 것 같습니다.</p>

<h2 id="개발-후기">개발 후기</h2>

<p>4인 개발 팀이었지만 저와 팀장 둘이서 거의 모든 기능을 구현하기도 하고 여러 버그가 남아 있어 관리적 측면에선 실패한 프로젝트입니다. 하지만 이를 경험하면서 애자일방식 개발과 의사소통의 필요성을 느끼게 되었고 이후 프로젝트들에서 이에서 많은 것들을 피드백하여 개선할 수 있었습니다.</p>

<h2 id="요약">요약</h2>

<table>
  <th></th>    
  <th>내용</th>
  <tr>
      <td>인원</td>
      <td>4</td>
  </tr>
  <tr>
      <td>개발기간</td>
      <td>2019.03~2019.06</td>
  </tr>
  <tr>
      <td>배포</td>
      <td><a href="https://play.google.com/store/apps/details?id=std.neomind.brainmanager">플레이스토어 링크</a></td>
  </tr>
  <tr>
      <td>성과</td>
      <td> 플레이스토어 50회 이상 설치 </td>
  </tr>
</table>

<hr />

<h2 id="개발환경">개발환경</h2>

<table>
  <th>범주</th>    
  <th>스택</th>
  <tr>
    <td>언어</td>
    <td><img src="https://img.shields.io/badge/Java-Java 8-007ACC?style=flat&amp;logo=Java&amp;logoColor=white" /></td>
  </tr>
  <tr>
    <td>개발도구</td>
    <td><img src="https://img.shields.io/badge/Android-Android SDK 29-007A1C?style=flat&amp;logo=Android&amp;logoColor=white" /><img src="https://img.shields.io/badge/빌드-Gradle-A07ACC?style=flat&amp;logo=Gradle&amp;logoColor=white" /></td>
  </tr>
  <tr>
    <td>주요 패키지</td>
    <td><pre>
<img src="https://img.shields.io/badge/이미지뷰어-Baseflow/PhotoView-007ACC?style=flat&amp;logo=Android&amp;logoColor=white" />
<img src="https://img.shields.io/badge/재사용뷰어-wasabeef/recyclerview--animators-50AFCC?style=flat&amp;logo=Android&amp;logoColor=white" />
<img src="https://img.shields.io/badge/원형이미지-lopspower/CircularImageView-502ACC?style=flat&amp;logo=Android&amp;logoColor=white" />
<img src="https://img.shields.io/badge/차트-PhilJay/MPAndroidChart-502ACC?style=flat&amp;logo=Android&amp;logoColor=white" /><img src="https://img.shields.io/badge/머터리얼텍스트-rengwuxian/MaterialEditText-502ACC?style=flat&amp;logo=Android&amp;logoColor=white" /><img src="https://img.shields.io/badge/인트로페이지-matthewbradshaw--io/SlidingIntroScreen-502ACC?style=flat&amp;logo=Android&amp;logoColor=white" /></pre>
    </td>
  </tr>
</table>

<h2 id="실행화면">실행화면</h2>

<p><img src="https://play-lh.googleusercontent.com/ZFxOZzER0NgrHYLM58D7Ma9xm-ZFdvu9tDweGUor6K_g7dqm9ErbWaM4fwn_Ys_Q0woS=w2560-h1440-rw" alt="App 화면 1" /></p>

<p><img src="/assets/img/portfolio/mainproject/브래인매니저/2.png" alt="App 화면 2" /></p>

<p><img src="/assets/img/portfolio/mainproject/브래인매니저/3.png" alt="App 화면 3" /></p>

<h2 id="주요-역할">주요 역할</h2>

<h3 id="설계">설계</h3>

<ul>
  <li>아이디어 제안자로서 아키텍처 설계</li>
</ul>

<h3 id="구현">구현</h3>

<ul>
  <li>복습 화면</li>
  <li>복습 알림 알고리즘(간격 반복 알고리즘)</li>
  <li>관계성 설정</li>
  <li>푸시 알림</li>
  <li>야간모드</li>
  <li>SQLite 쿼리</li>
  <li>Locale별 언어 처리</li>
  <li>안드로이드 버전별 동작 처리</li>
</ul>

<h2 id="애플리케이션-아키텍처">애플리케이션 아키텍처</h2>

<p><img src="/assets/img/portfolio/mainproject/브래인매니저/1.png" alt="App 아키텍처" /></p>]]></content><author><name>redniche yechankun</name></author><category term="포트폴리오" /><category term="메인프로젝트" /><category term="니체" /><category term="예찬군" /><category term="안드로이드" /><category term="앱" /><category term="SQLite" /><summary type="html"><![CDATA[NeoMindStd/BrainManager 프로젝트]]></summary></entry><entry><title type="html">웹 디자인-헬스가든</title><link href="https://yechankun.github.io/posts/%EC%9B%B9-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%97%AC%EC%8A%A4%EA%B0%80%EB%93%A0/" rel="alternate" type="text/html" title="웹 디자인-헬스가든" /><published>2022-03-20T21:43:00+09:00</published><updated>2022-03-21T00:50:12+09:00</updated><id>https://yechankun.github.io/posts/%EC%9B%B9-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%97%AC%EC%8A%A4%EA%B0%80%EB%93%A0</id><content type="html" xml:base="https://yechankun.github.io/posts/%EC%9B%B9-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%97%AC%EC%8A%A4%EA%B0%80%EB%93%A0/"><![CDATA[<h2 id="헬스가든이란">헬스가든이란?</h2>

<p>㈜ 바이오앤라이프에서 운영하는 온라인 쇼핑몰입니다.</p>

<p><a href="https://blog.naver.com/kwak5336">https://blog.naver.com/kwak5336</a></p>

<p>와 같이 홍보용 블로그를 운영하면서 여러 한방제품들을 판매하는 회사입니다.</p>

<h2 id="개발-배경">개발 배경</h2>

<p>제가 학부 4학년 때 교외 국가 근로를 진행하면서 위의 업체에서 근로를 진행했었는데 사장님이 저의 개발 능력으로 홈페이지 재단장을 요청하셔서 진행했습니다.</p>

<p>보통 국가 근로를 하면서 이런 일을 하지는 않지만 저는 이것 또한 경험을 넓히고 사회에 공헌하는 기회라 생각하여 잘 만들어 보기 위해 노력했습니다.</p>

<h2 id="개요">개요</h2>

<table>
    <th>범주</th>    
    <th>스택</th>
    <tr>
        <td>언어</td>
        <td><img src="https://img.shields.io/badge/HTML-007ACC?style=flat&amp;logo=html5&amp;logoColor=white" /><img src="https://img.shields.io/badge/JavaScript-007ACC?style=flat&amp;logo=JavaScript&amp;logoColor=white" /><img src="https://img.shields.io/badge/CSS-007ACC?style=flat&amp;logo=CSS3&amp;logoColor=white" /></td>
    </tr>
    <tr>
        <td>개발환경</td>
        <td><img src="https://img.shields.io/badge/Visual Studio Code-007ACC?style=flat&amp;logo=VisualStudioCode&amp;logoColor=white" /></td>
    </tr>
    <tr>
        <td>호스팅</td>
        <td><img src="https://img.shields.io/badge/CAFE24-웹호스팅업체-007ACC?style=flat&amp;logo=Buy Me A Coffee&amp;logoColor=white" /></td>
    </tr>
</table>

<h2 id="결과물">결과물</h2>

<p>사이트 링크: <a href="https://health-garden.shop/">https://health-garden.shop/</a></p>

<p><img src="/assets/img/portfolio/subproject/웹디자인헬스가든/메인1.png" alt="메인1" />
<img src="/assets/img/portfolio/subproject/웹디자인헬스가든/메인2.png" alt="메인2" /></p>]]></content><author><name>redniche yechankun</name></author><category term="포트폴리오" /><category term="서브프로젝트" /><category term="니체" /><category term="예찬군" /><category term="웹디자인" /><category term="Cafe24" /><category term="웹호스팅" /><summary type="html"><![CDATA[헬스가든이란?]]></summary></entry></feed>