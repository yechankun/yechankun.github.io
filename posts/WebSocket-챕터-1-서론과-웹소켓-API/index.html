<!DOCTYPE html><html lang="ko-KR" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /><meta name="prefer-datetime-locale" content="ko" /><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="WebSocket 챕터 #1: 서론과 웹소켓 API" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="웹소켓(WebSocket) 서론" /><meta property="og:description" content="웹소켓(WebSocket) 서론" /><link rel="canonical" href="https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/" /><meta property="og:url" content="https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/" /><meta property="og:site_name" content="니체의 개발 인생" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-17T09:03:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="WebSocket 챕터 #1: 서론과 웹소켓 API" /><meta name="twitter:site" content="@" /><meta name="google-site-verification" content="JvuBoR3bSTp-Eg0nEkFh2N02PxVYRvHz8omFXcFoePg" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-23T11:41:41+09:00","datePublished":"2023-04-17T09:03:00+09:00","description":"웹소켓(WebSocket) 서론","headline":"WebSocket 챕터 #1: 서론과 웹소켓 API","mainEntityOfPage":{"@type":"WebPage","@id":"https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/"},"url":"https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/"}</script><title>WebSocket 챕터 #1: 서론과 웹소켓 API | 니체의 개발 인생</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="니체의 개발 인생"><meta name="application-name" content="니체의 개발 인생"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" /><link rel="dns-prefetch" href="https://fonts.googleapis.com" /><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin /><link rel="preconnect" href="https://fonts.googleapis.com" /><link rel="dns-prefetch" href="https://fonts.googleapis.com" /><link rel="preconnect" href="https://cdn.jsdelivr.net" /><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" /><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap" /><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials" /><link rel="dns-prefetch" href="https://www.google-analytics.com" /><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous" /><link rel="dns-prefetch" href="https://www.googletagmanager.com" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" /><link rel="stylesheet" href="/assets/css/style.css?v=1682602155" /><link rel="stylesheet" type="text/css" href="/assets/css/linkpreview.css" media="screen" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" onmouseenter="showSidebar()" onmouseleave="hideSidebar()" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/yechankun_profile.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">니체의 개발 인생</a></div><div class="site-subtitle font-italic">예찬군</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/yechankun" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['redniche','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><script> function showSidebar() { document.getElementById("sidebar").classList.add("expanded"); } function hideSidebar() { document.getElementById("sidebar").classList.remove("expanded"); } </script><div id="topbar-wrapper" class="row"><div id="topbar" class="col-11 d-flex h-100 align-items-center ml-3"> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i> <span id="breadcrumb"> <span> <a href="/"> 니체의 개발 인생 </a> </span> <span> <a href="/categories/%ea%b0%9c%eb%b0%9c/">개발</a> </span> <span> <a href="/categories/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac/">네트워크</a> </span> <span>WebSocket 챕터 #1: 서론과 웹소켓 API</span> </span><div class="search-elements-group d-flex align-items-center ml-auto"> <i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>WebSocket 챕터 #1: 서론과 웹소켓 API</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/yechankun">yechankun</a> </em></div><div class="d-flex"><div> <span> 게시 <em class="timeago" data-ts="1681689780" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2023-04-17 </em> </span> <span> 업데이트 <em class="timeago" data-ts="1682217701" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2023-04-23 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6741 단어"> <em>37 분</em>읽는 시간</span></div></div></div><div class="post-content"><h2 id="웹소켓websocket-서론"><span class="mr-2">웹소켓(WebSocket) 서론</span><a href="#웹소켓websocket-서론" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>WebSocket은 브라우저와 서버 간의 양방향 메시지 전송을 가능하게 하는 프로토콜입니다. 웹소켓은 브라우저에서 사용할 수 있는 가장 효과적이고 유연한 통신 수단 중 하나로, 기존 HTTP 인프라와의 상호 운용성을 제공하며, 메시지 중심 통신 및 효율적인 메시지 프레이밍을 통해 클라이언트와 서버 간에 원활한 데이터 스트리밍이 가능합니다.</p><h3 id="주요-특징"><span class="mr-2"><strong>주요 특징</strong></span><a href="#주요-특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>연결 협상 및 동일 출처 정책 시행<li>기존 HTTP 인프라와의 상호 운용성<li>메시지 중심 통신 및 효율적인 메시지 프레이밍<li>서브프로토콜 협상 및 확장성</ul><p>웹소켓은 간단한 JSON 페이로드부터 사용자 지정 바이너리 메시지 형식까지 클라이언트와 서버 간에 다양한 애플리케이션 프로토콜을 계층화하여 전달할 수 있습니다. 이를 통해 양쪽 모두 언제든지 데이터를 전송할 수 있습니다.</p><p>그러나 사용자 정의 프로토콜의 단점은 바로 사용자 정의라는 점입니다. 애플리케이션은 브라우저에서 제공하는 상태 관리, 압축, 캐싱 등의 기능을 고려해야 합니다.</p><p>웹소켓을 사용할 때 항상 설계상의 제약과 성능의 절충점이 존재합니다. 최상의 성능을 위해서는 각 프로토콜과 전송 방식의 강점을 활용하는 것이 중요합니다.</p><h3 id="결론"><span class="mr-2"><strong>결론</strong></span><a href="#결론" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>웹소켓은 HTTP, XHR, 또는 SSE를 완전히 대체할 수는 없습니다. 오히려, 이 프로토콜들의 강점을 활용하여 웹 애플리케이션의 성능과 사용성을 최적화하는 것이 바람직합니다. 웹소켓은 강력한 통신 도구이지만, 제약 사항과 장단점을 고려하여 적절한 사용이 필요합니다.</p><p><em>웹소켓은 여러 표준의 집합으로, 웹소켓 API는 W3C에서 정의하고 웹소켓 프로토콜(RFC 6455)와 그 확장은 HyBi 워킹 그룹(IETF)에서 정의합니다.</em></p><h2 id="웹소켓-api-websocket-api"><span class="mr-2">웹소켓 API (WebSocket API)</span><a href="#웹소켓-api-websocket-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>브라우저에서 직접 제공하는 웹소켓 API는 매우 작고 간단합니다. <strong><em>연결 관리 및 메시지 처리의 모든 하위 수준 세부사항은 브라우저에서 처리</em></strong> 합니다. 웹소켓 리소스의 URI와 애플리케이션 콜백이 필요한데, 아래 예제에서 코드를 확인할 수 있습니다.</p><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">//1. 새 보안 웹소켓 연결(wss) 열기</span>
<span class="kd">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws://example.com/socket</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">//2. 웹소켓 연결이 설정될 때 호출되는 선택적 콜백</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">ws</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">);</span> <span class="c1">//3. 클라이언트가 서버로 보내는 메시지</span>
<span class="p">};</span>

<span class="c1">//4. 서버에서 새 메시지를 보낼 때마다 호출되는 콜백 함수</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span> <span class="k">instanceof</span> <span class="nx">Blob</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">processBlob</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="c1">//5. 수신된 바이너리 메시지 처리 로직 호출</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">processText</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="c1">//6. 수신된 텍스트 메시지 처리 로직 호출</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//7. 연결 오류가 발생한 경우 호출되는 선택적 콜백</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="c1">//8. 연결이 종료될 때 호출되는 선택적 콜백</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onclose</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><p>EventSource API와 비슷한 경험을 제공하면서도 웹소켓은 더 다양한 기능을 지원합니다. 이러한 유사성은 웹소켓이 기존 API와 호환성을 유지하면서 확장성을 제공하기 위한 의도적인 설계입니다.</p><p>하지만 몇 가지 중요한 차이점이 있습니다.</p><ol><li>웹소켓은 양방향 통신을 지원하며, 클라이언트와 서버가 서로 메시지를 주고받을 수 있습니다. 반면, EventSource는 서버에서 클라이언트로의 단방향 통신만 지원합니다. 그리고 그 과정에서 서로 다른 프로토콜을 사용합니다.(EventSource Protocol 과 WebSocket Protocol)<li>웹소켓은 텍스트뿐만 아니라 바이너리 데이터도 전송할 수 있습니다. EventSource는 텍스트 데이터만 전송할 수 있습니다.<li>WebSocket은 서브프로토콜을 정의할 수 있습니다. 클라이언트와 서버는 이런 사용자 지정 프로토콜을 사용하여 데이터를 주고받을 수 있습니다. 예를 들어, JSON, XML, 또는 protobuf와 같은 데이터 형식을 사용하여 데이터를 전송할 수 있습니다. 또한, 서브 프로토콜을 사용하면, 각각의 특화된 기능을 구현할 수 있습니다.</ol><p>추가적인 내용은 아래에서 알아보겠습니다.</p><details> <summary>브라우저의 웹소켓 애뮬레이팅 (Emulating WebSocket In The Browser)</summary><div><p>웹소켓 프로토콜은 클라이언트와 서버간 실시간 양방향 통신을 위한 프로토콜입니다. 최신 버전(v13)으로 발전해 모든 브라우저에서 지원되며, 브라우저 지원 상황은 <strong><a href="http://caniuse.com/websockets%EC%97%90%EC%84%9C">http://caniuse.com/websockets에서</a></strong> 확인 가능합니다.</p><p>하지만, 일부 브라우저에서는 웹소켓을 지원하지 않는 경우가 있으므로, 이를 대비하여 에뮬레이션하는 라이브러리가 필요합니다. 하지만, 웹소켓 API를 에뮬레이션하는 라이브러리는 전송에 어려움이 있어 성능에 영향을 미치는 경우가 있습니다.</p><p>이를 해결하기 위해 SockJS와 같은 라이브러리는 “seamless fallback”을 가능하게 합니다. 이는 브라우저에서 웹소켓을 지원하지 않는 경우, SockJS가 웹소켓 대신 다른 전송 방법을 사용하여 대체합니다. 이를 통해 브라우저 호환성을 보장하면서도 성능 문제를 해결할 수 있습니다.</p><p>또한, Socket.IO와 같은 라이브러리는 고급 기능을 추가로 제공합니다. 이러한 라이브러리를 사용하면 실시간 프레임워크를 쉽게 구현할 수 있으며, 구현과 구성을 최적화하여 성능을 향상시킬 수 있습니다. 이러한 라이브러리는 이벤트 기반 프로그래밍 모델을 제공하여 클라이언트와 서버 간의 통신을 단순화하며, 클라이언트 측에서도 간편하게 구현할 수 있습니다.</p><p>따라서, 웹소켓을 이용한 실시간 양방향 통신을 구현하려면 브라우저 호환성을 고려하고, 성능 문제를 해결하기 위해 에뮬레이션하는 라이브러리와 고급 기능을 제공하는 라이브러리를 적절히 선택하여 사용해야 합니다.최상의 성능을 얻기 위해 네이티브 웹소켓 인터페이스를 활용하고, 폴백 전송 성능을 최적화하여 전반적인 통신 성능을 향상시키세요.</p></div></details><h3 id="ws와-wss-url-스키마-ws-and-wss-url-schemes"><span class="mr-2">WS와 WSS URL 스키마 (WS and WSS URL Schemes)</span><a href="#ws와-wss-url-스키마-ws-and-wss-url-schemes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>WebSocket 프로토콜은?</p><ul><li>웹소켓 프로토콜은 IETF(Internet Engineering Task Force)의 HyBi Working Group에서 제정되었습니다.<li>이 그룹은 브라우저와 서버 간 통신에서 발생하는 문제를 해결하고 최적화된 양방향 통신 채널을 구축하기 위해 웹소켓 프로토콜을 만들었습니다.<li>웹소켓 프로토콜은 브라우저와 서버 간 최적화된 양방향 통신 채널을 구축하기 위해 HTTP 대신 자체 사용자 지정 스키마를 사용합니다.</ul><p><strong>웹소켓 프로토콜의 URL 스키마</strong></p><ul><li>일반 텍스트 통신에는 ‘ws’를 사용합니다.<li>암호화된 채널(TCP+TLS)이 필요한 경우에는 ‘wss’를 사용합니다.</ul><p><strong>웹소켓 프로토콜의 확장성</strong></p><ul><li>브라우저 외부에서도 비 HTTP 교환을 통해 협상할 수 있도록 확장성을 제공합니다.<li>하지만, 사용자 지정 체계에서는 웹소켓 세션을 설정하기 위한 대체 핸드셰이크 메커니즘에 대한 기존 표준이 없어 추가적인 작업이 필요합니다.</ul><blockquote><p><strong>정리</strong> 웹소켓 프로토콜은 브라우저와 서버 간 최적화된 양방향 통신 채널을 제공하며, HTTP 대신 자체 사용자 지정 스키마를 사용합니다. 일반 텍스트 통신에는 ‘ws’를 사용하고, 암호화된 채널이 필요한 경우에는 ‘wss’를 사용합니다. 또한, 웹소켓은 브라우저 외부에서도 비 HTTP 교환을 통해 협상할 수 있도록 확장성을 제공하지만, 사용자 지정 체계에서는 추가적인 작업이 필요합니다.</p></blockquote><h3 id="텍스트-및-바이너리-데이터-수신-receiving-text-and-binary-data-by-websocket"><span class="mr-2">텍스트 및 바이너리 데이터 수신 (<strong>Receiving Text and Binary Data By WebSocket)</strong></span><a href="#텍스트-및-바이너리-데이터-수신-receiving-text-and-binary-data-by-websocket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>웹소켓을 사용하여 텍스트와 바이너리 데이터를 효율적으로 전송하고 수신할 수 있습니다.</p><ol><li><strong>메시지와 애플리케이션 코드 구성</strong><ul><li>웹소켓은 메시지와 애플리케이션 코드로 구성되어 사용자가 데이터의 버퍼링, 구문 분석 및 재구성에 대해 걱정할 필요가 없습니다.</ul><li><strong>데이터 처리의 유연성</strong><ul><li>웹소켓은 텍스트와 바이너리 데이터 모두 처리할 수 있으며, 애플리케이션 페이로드에 대한 제약이나 가정을 두지 않습니다.</ul><li><strong>페이로드 정보 추적</strong><ul><li>웹소켓 프로토콜은 메시지에 대한 두 가지 정보만 추적합니다.<ul><li>페이로드 길이: 가변 길이 필드로서 메시지의 길이를 나타냅니다.<li>페이로드 유형: UTF-8과 바이너리 전송을 구분하기 위한 정보를 포함합니다.</ul></ul><li><strong>데이터 자동 변환 및 전달</strong><ul><li>브라우저가 새 메시지를 수신할 때, 텍스트 기반 데이터는 DOMString 객체로, 바이너리 데이터는 Blob 객체로 자동 변환된 다음 애플리케이션에 전달됩니다.</ul><li><p><strong>성능 최적화 옵션</strong></p><ul><li>수신된 바이너리 데이터를 Blob 대신 ArrayBuffer로 변환하도록 브라우저에 지시함으로써 데이터 처리를 더욱 효율적으로 수행할 수 있습니다.</ul><blockquote><p>Blob이란?</p><ul><li>변경 불가능한 원시 데이터로 구성된 파일과 같은 객체이며 데이터를 수정할 필요가 없고 더 작은 덩어리로 분할할 필요가 없습니다.<ul><li>예: 전체 Blob 객체를 이미지 태그에 전달할 수 있는 경우 최적의 형식(<a href="https://hpbn.co/xmlhttprequest/#downloading-data-with-xhr">XHR로 데이터 다운로드의 예</a> 참조)</ul><li>반면에 바이너리 데이터에 추가 처리를 수행해야 하는 경우 ArrayBuffer가 더 적합할 수 있습니다.</ul></blockquote></ol><p>아래는 성능 최적화 옵션을 사용한 예시입니다.</p><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">ws://example.com/socket</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// 바이너리 메시지 수신 시 ArrayBuffer 변환 강제 수행</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">binaryType</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">arraybuffer</span><span class="dl">"</span><span class="p">;</span>

<span class="nx">ws</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span> <span class="k">instanceof</span> <span class="nb">ArrayBuffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">processArrayBuffer</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">processText</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><blockquote><p>User agents는 이 속성을 수신 바이너리 데이터를 처리하는 방법에 대한 힌트로 사용할 수 있습니다. 속성이 “blob”으로 설정되어 있으면 디스크에 스풀링(데이터를 채우는 것)하는 것이 안전하며, “arraybuffer”로 설정되어 있으면 데이터를 메모리에 보관하는 것이 더 효율적일 가능성이 높습니다. 물론 사용자 에이전트는 수신 데이터를 메모리에 보관할지 여부를 결정하기 위해 보다 미묘한 휴리스틱을 사용하도록 권장됩니다.</p></blockquote><p><em>The WebSocket API, W3C Candidate Recommendation</em></p><details> <summary>자바스크립트를 이용한 웹소켓에서 받은 바이너리 데이터 디코딩</summary><div><p>예시로 C로 작성된 구조체의 객체를 메시지로 받아 웹소켓에서 디코딩하는 과정을 설명합니다.</p><p>먼저, 다음과 같은 C 스타일의 바이너리 데이터 구조를 고려해봅시다.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">personInfo</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 이렇게 할당되어 있다 가정합니다.</span>
<span class="k">struct</span> <span class="n">personInfo</span> <span class="n">person</span> <span class="o">=</span> <span class="p">{</span><span class="s">"John Doe"</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">180</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">};</span>
</pre></table></code></div></div><p>이 구조체는 사람의 정보를 담고 있습니다. 이름은 20바이트의 문자 배열, 나이는 unsigned int 형식, 그리고 키는 float 형식으로 구성되어 있습니다.</p><p>웹소켓에서 이벤트를 받으면 다음과 같이 처리할 수 있습니다. 다음 예시처럼 WebSocket은 브라우저 내에서 바이너리 데이터를 처리하는 데 필요한 도구를 애플리케이션에 제공합니다.</p><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="nx">websocket</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>

  <span class="c1">// TypedArray를 사용한 방식</span>
  <span class="kd">var</span> <span class="nx">nameView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint8Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">ageView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Uint32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">heightView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Float32Array</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// 출력: Name: John Doe, Age: 30, Height: 180.5</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span>
    <span class="dl">"</span><span class="s2">Name: </span><span class="dl">"</span> <span class="o">+</span>
      <span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">nameView</span><span class="p">)</span> <span class="o">+</span>
      <span class="dl">"</span><span class="s2">, Age: </span><span class="dl">"</span> <span class="o">+</span>
      <span class="nx">ageView</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
      <span class="dl">"</span><span class="s2">, Height: </span><span class="dl">"</span> <span class="o">+</span>
      <span class="nx">heightView</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">);</span>

  <span class="c1">// DataView를 사용한 방식</span>
  <span class="kd">var</span> <span class="nx">dataView</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataView</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
  <span class="nf">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">+=</span> <span class="nb">String</span><span class="p">.</span><span class="nf">fromCharCode</span><span class="p">(</span><span class="nx">dataView</span><span class="p">.</span><span class="nf">getUint8</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">age</span> <span class="o">=</span> <span class="nx">dataView</span><span class="p">.</span><span class="nf">getUint32</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">dataView</span><span class="p">.</span><span class="nf">getFloat32</span><span class="p">(</span><span class="mi">24</span><span class="p">);</span>

  <span class="c1">// 출력: Name: John Doe, Age: 30, Height: 180.5</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Name: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">, Age: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">age</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">, Height: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">height</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><p>위의 예시에서 ArrayBuffer를 각각 TypedArray 방식과 DataView 방식으로 바이너리 데이터를 해독하고 있습니다.</p></div></details><h3 id="websocket텍스트-바이너리-데이터-전송-sending-text-and-binary-data-with-websocket"><span class="mr-2">WebSocket텍스트 바이너리 데이터 전송 (<strong>Sending Text and Binary Data with WebSocket)</strong></span><a href="#websocket텍스트-바이너리-데이터-전송-sending-text-and-binary-data-with-websocket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>WebSocket을 사용하면 클라이언트와 서버 간에 텍스트 및 바이너리 데이터를 쉽게 주고받을 수 있습니다. WebSocket 프로토콜은 TCP 연결을 통해 양방향 메시지 전달이 가능하게 합니다. 이를 구현하는 과정은 다음과 같습니다.</p><ol><li>WebSocket API 사용 데이터 WebSocket API는 다음과 같은 데이터 유형을 지원합니다.<ul><li>UTF-8 인코딩된 문자열<li>바이너리 전송을 위한 ArrayBuffer, ArrayBufferView, Blob 객체</ul><li><p>WebSocket 연결 생성 및 데이터 전송 웹 애플리케이션에서 이미지 파일과 텍스트 메시지를 동시에 전송해야 한다고 가정해봅시다.<br /> 이 경우 다음과 같이 WebSocket 연결을 생성하고 데이터를 전송할 수 있습니다.</p><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">'</span><span class="s1">ws://example.com/socket</span><span class="dl">'</span><span class="p">);</span>

    <span class="nx">ws</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// 텍스트 메시지 전송</span>
      <span class="nx">ws</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello!</span><span class="dl">"</span><span class="p">);</span>

      <span class="c1">// 바이너리 데이터 (예: 이미지 파일) 전송</span>
      <span class="kd">var</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>
      <span class="nx">ws</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="s2">```

</span></pre></table></code></div></div><li>send() 메서드 및 비동기 처리 send() 메서드는 비동기식으로 처리되며, 데이터는 클라이언트에 의해 큐에 대기됩니다.<br /> 함수는 즉시 반환되므로 대용량 페이로드 전송 시 전송 완료 신호로 오해하지 않도록 주의해야 합니다.<li><p>데이터 양 모니터링 애플리케이션에서는 소켓의 bufferedAmount 속성을 사용하여 브라우저에서 대기 중인 데이터 양을 모니터링할 수 있습니다.<br /> bufferedAmount가 0인 경우에만 send 메서드를 호출하여 데이터를 전송하는 방식도 있습니다. 이렇게 함으로써, 소켓의 대기열에 너무 많은 데이터가 쌓이는 것을 예방할 수 있습니다.</p><p>다음은 만약 시스템에 업데이트가 발생했다면 서버의 데이터 갱신을 bufferedAmount가 0일 때에만 send를 호출하는 간단한 예제 코드입니다.</p><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">ws://example.com</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">updateInterval</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// 1초마다 시스템 업데이트 체크</span>

<span class="kd">function</span> <span class="nf">checkUpdate</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 시스템 업데이트 체크 후 업데이트가 있을 경우, 서버에 전송</span>
  <span class="kd">var</span> <span class="nx">updateData</span> <span class="o">=</span> <span class="nf">getUpdateData</span><span class="p">();</span> <span class="c1">// 시스템 업데이트 데이터 가져오기</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">updateData</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">updateData</span><span class="p">));</span> <span class="c1">// 업데이트 데이터를 JSON 문자열로 변환하여 전송</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 일정 주기마다 시스템 업데이트 체크</span>
<span class="nf">setInterval</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">checkUpdate</span><span class="p">();</span>
<span class="p">},</span> <span class="nx">updateInterval</span><span class="p">);</span>
</pre></table></code></div></div><p>위 예제 코드에서 checkUpdate 함수는 일정 주기마다 시스템 업데이트를 체크합니다. 시스템 업데이트가 있을 경우, 해당 업데이트 데이터를 JSON 형태로 변환한 후, WebSocket을 사용하여 서버에 전송합니다.</p><p>시스템은 옵저버 패턴 등을 활용해서 더욱 구조적으로 구성할 수도 있습니다.</p><p>이렇게 함으로써, 소켓의 대기열에 데이터가 많이 쌓이는 것을 예방하고 HOL 차단 현상을 완화할 수 있습니다. HOL 차단 현상을 완전히 해결하는 것은 아니지만, HOL 차단 현상을 예방하거나 완화하는데에 도움을 줄 수 있습니다.</p><li><p>Head of Line (HOL) 차단 현상 해결 전송을 최적화하려면 각 메시지 유형이 소켓에 대기열에 포함되는 방식과 시기에 세심한 주의를 기울여야 합니다. 이를 통해 Head of Line (HOL) 차단 현상을 해결할 수 있습니다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>- 메시지 유형별 대기열 사용: 각 메시지 유형에 대한 대기열을 따로 유지하여, 큰 데이터 덩어리가 전송될 때 작은 데이터 덩어리가 먼저 전송되는 현상을 막을 수 있습니다. 예를 들어, 문자열과 바이너리 데이터를 구분하여 따로 전송하는 것이 좋습니다.
- 작은 데이터 덩어리 우선 전송: 큰 데이터 덩어리가 전송될 때는 작은 데이터 덩어리를 먼저 전송하는 것이 좋습니다. 이를 위해서는 메시지 크기를 제한하거나, 메시지가 큰 경우에는 여러 개의 작은 데이터 덩어리로 분할하여 전송하는 방법을 사용할 수 있습니다.
- 프로토콜 수준에서 해결: WebSocket 프로토콜 자체에서 HOL 차단 현상을 해결하는 기능을 제공할 수 있습니다. 예를 들어, WebSocket 스펙의 중간에 데이터를 전송할 수 있는 형식인 "Continuation Frames"을 사용하는 것이 좋습니다. 이를 이용하면, 큰 데이터 덩어리를 여러 개의 작은 데이터 덩어리로 분할하여 전송할 수 있으며, 이를 받는 쪽에서는 이들을 조합하여 전체 데이터를 복원할 수 있습니다.
- bufferedAmount를 확인하면 HOL를 예방하는 것엔 도움이 됩니다. 하지만 위와 같은 방식을 사용해서 근본적으로 HOL의 문제를 해결하는 것이 좋습니다.
</pre></table></code></div></div></ol><blockquote><p>많은 애플리케이션은 제어 트래픽과 같은 우선순위가 높은 업데이트와 백그라운드 전송과 같은 우선순위가 낮은 업데이트 등 여러 클래스의 메시지를 생성합니다.</p></blockquote><p>전송을 최적화하려면 애플리케이션은 각 메시지 유형이 소켓에 대기열에 포함되는 방식과 시기에 세심한 주의를 기울여야 합니다!</p><blockquote></blockquote><h3 id="서브프로토콜-협상"><span class="mr-2">서브프로토콜 협상</span><a href="#서브프로토콜-협상" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>WebSocket 프로토콜</p><ul><li>웹소켓 프로토콜은 각 메시지의 형식에 대해 어떠한 가정도 하지 않습니다.<ul><li>단일 비트는 메시지에 텍스트 또는 바이너리 데이터가 포함되어 있는지 여부를 추적해 클라이언트와 서버가 효율적으로 디코딩할 수 있도록 하지만 그렇지 않은 경우 메시지 내용은 불투명합니다.</ul><li>각 요청과 응답의 HTTP 헤더를 통해 추가 메타데이터를 전달하는 HTTP 또는 XHR 요청과 달리 웹소켓 메시지에는 이와 동등한 메커니즘이 없습니다.<li>메시지에 대한 추가 메타데이터가 필요한 경우 클라이언트와 서버가 이런 데이터를 전달하기 위해 자체 서브프로토콜을 구현해야 합니다.<li>클라이언트와 서버는 고정된 메시지 형식에 미리 합의할 수 있습니다.<ul><li>예를 들어, 모든 통신은 JSON 인코딩된 메시지 또는 사용자 정의 바이너리 형식을 통해 이루어지며 필요한 메시지 메타데이터는 인코딩된 구조의 일부 형식 사용합니다.</ul><li>클라이언트와 서버가 서로 다른 데이터 유형을 전송해야 하는 경우 일관된 메시지 헤더를 구성해야 하며, 이를 통해 나머지 페이로드를 디코딩하기 위한 지침을 전달할 수 있습니다.<li>텍스트 메시지와 바이너리 메시지를 혼합하여 페이로드와 메타데이터 정보를 전달할 수 있습니다.<ul><li>예를 들어 텍스트 메시지로 HTTP 헤더에 해당하는 내용을 전달한 다음 바이너리 메시지로 애플리케이션 페이로드를 전달할 수 있습니다.</ul></ul><p>웹소켓은 메시지의 유연성과 낮은 오버헤드를 제공하지만, 메시지 직렬화와 메타데이터 관리는 문제의 일부입니다. 서로 다른 클라이언트와 서버 간에 동기화를 유지하려면 프로토콜 협상이 필요합니다.</p><p>웹소켓은 <strong><code class="language-plaintext highlighter-rouge">서브프로토콜 협상 API</code></strong>를 제공하여 이 문제를 해결합니다. 클라이언트는 초기 연결 핸드셰이크를 통해 어떤 프로토콜을 지원하는지 서버에 알릴 수 있습니다.<br /> 이를 통해 클라이언트와 서버는 동일한 프로토콜을 사용하고 메시지 형식 및 메타데이터의 구조를 미리 합의할 수 있습니다.</p><div class="language-javascript highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WebSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">ws://example.com/socket</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span>
  <span class="dl">"</span><span class="s2">chat</span><span class="dl">"</span><span class="p">,</span>
  <span class="dl">"</span><span class="s2">notification</span><span class="dl">"</span><span class="p">,</span>
<span class="p">]);</span>

<span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">if </span><span class="p">(</span><span class="nx">socket</span><span class="p">.</span><span class="nx">protocol</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">chat</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 서버와 클라이언트가 합의한 'chat' 서브프로토콜에 따른 로직 수행</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if </span><span class="p">(</span><span class="nx">socket</span><span class="p">.</span><span class="nx">protocol</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">notification</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 서버와 클라이언트가 합의한 'notification' 서브프로토콜에 따른 로직 수행</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>이 예시에서는 <strong><code class="language-plaintext highlighter-rouge">chat</code></strong>과 <strong><code class="language-plaintext highlighter-rouge">notification</code></strong> 두 가지 서브프로토콜을 WebSocket 생성자에 전달합니다. 클라이언트는 초기 핸드셰이크 중에 서버에게 이를 알리며, 서버는 클라이언트가 지정한 서브프로토콜 중 하나를 선택하여 응답합니다.</p><p>하위 프로토콜 협상이 성공하면 클라이언트에서 onopen 콜백이 실행되고 WebSocket 객체의 프로토콜 속성을 통해 선택한 프로토콜을 확인할 수 있습니다. 클라이언트와 서버는 이를 통해 메시지의 형식과 메타데이터 구조를 미리 합의할 수 있습니다.</p><p>서브프로토콜 이름은 애플리케이션에서 정의되며, 초기 핸드셰이크 중에 클라이언트가 서버에게 전송됩니다. 코어 웹소켓 API에는 서브프로토콜 이름에 대한 특별한 처리 방법이 없으며, 지정된 서브프로토콜은 애플리케이션 로직과 관련된 부분입니다.</p><blockquote><p>선택적으로 onerror를 이용해서 협상에 실패했을 때의 동작을 추가할 수 있습니다.</p></blockquote><p>웹소켓 API를 사용하면 쉽게 웹소켓 연결을 관리하고 메시지를 처리할 수 있으며, 높은 유연성과 확장성을 제공합니다. 이를 통해 실시간 웹 애플리케이션 및 서비스에 최적화된 솔루션을 구현할 수 있습니다. 하지만 다음과 같은 유의사항도 있습니다.</p><ul><li>웹소켓은 기본적으로 연결 지향형이며, 네트워크 지연이나 연결 손실의 영향을 받을 수 있습니다.<li>웹소켓은 기본적으로 암호화되지 않음. 따라서 중요한 데이터를 전송할 때는 반드시 보안 웹소켓(wss)를 사용해야 합니다.<li>웹소켓은 전통적인 HTTP 프로토콜과는 다르게 작동하므로, 프록시 서버나 방화벽 설정에 주의해야 합니다. 이러한 문제를 해결하기 위해 기존 인프라와 웹소켓이 함께 작동하도록 구성할 수 있습니다.</ul><p>웹소켓 API는 높은 성능과 실시간 통신 기능을 제공하는 동시에 간단한 인터페이스를 유지합니다. 이를 통해 개발자들은 웹소켓 기반의 다양한 애플리케이션과 서비스를 구축할 수 있으며, 사용자에게 뛰어난 경험을 제공할 수 있습니다. 그러나 이를 사용하기 위해서는 웹소켓의 특성과 제약 사항을 이해하고 적절한 설계 및 구현이 필요합니다.</p><p>다음에는 이러한 웹소켓 API가 구현되기 위해 정의된 <code class="language-plaintext highlighter-rouge">웹소켓 프로토콜</code>에 대해 알아보겠습니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href="/categories/%EA%B0%9C%EB%B0%9C/" >개발</a >> <a href="/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/" >네트워크</a ></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%EB%8B%88%EC%B2%B4/" class="post-tag no-text-decoration" >니체</a> <a href="/tags/%EC%98%88%EC%B0%AC%EA%B5%B0/" class="post-tag no-text-decoration" >예찬군</a> <a href="/tags/websocket/" class="post-tag no-text-decoration" >WebSocket</a> <a href="/tags/socket/" class="post-tag no-text-decoration" >socket</a> <a href="/tags/%EC%9B%B9%EC%86%8C%EC%BC%93/" class="post-tag no-text-decoration" >웹소켓</a> <a href="/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/" class="post-tag no-text-decoration" >네트워크</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2" ><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=WebSocket 챕터 #1: 서론과 웹소켓 API - 니체의 개발 인생&amp;url=https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=WebSocket 챕터 #1: 서론과 웹소켓 API - 니체의 개발 인생&amp;u=https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://yechankun.github.io/posts/WebSocket-%EC%B1%95%ED%84%B0-1-%EC%84%9C%EB%A1%A0%EA%B3%BC-%EC%9B%B9%EC%86%8C%EC%BC%93-API/&amp;text=WebSocket 챕터 #1: 서론과 웹소켓 API - 니체의 개발 인생" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Git-%EC%86%8C%EA%B0%9C-%EB%B0%8F-%EA%B8%B0%EB%B3%B8-%EB%AA%85%EB%A0%B9%EC%96%B4/">Git 소개 및 기본 명령어</a><li><a href="/posts/Git-mirror-%EB%B0%A9%EB%B2%95/">Git mirror, 원격저장소에 미러링 하는 법</a><li><a href="/posts/%EB%B0%B1%EC%A4%80-%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0/">백준 줄 세우기 파이썬(Python) 풀이</a><li><a href="/posts/Jekyll-Blog-%EC%BA%90%EC%8B%9C%EB%B2%84%EC%8A%A4%ED%8C%85/">Jekyll, Html 캐시 비활성화 방법 cache-busting</a><li><a href="/posts/%EB%B0%B1%EC%A4%80-%EB%9E%9C%EC%84%A0-%EC%9E%90%EB%A5%B4%EA%B8%B0-%ED%92%80%EC%9D%B4,-%ED%8C%8C%EC%9D%B4%EC%8D%AC/">백준 랜선 자르기 풀이, 파이썬</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%8B%88%EC%B2%B4/">니체</a> <a class="post-tag" href="/tags/%EC%98%88%EC%B0%AC%EA%B5%B0/">예찬군</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/">블록체인</a> <a class="post-tag" href="/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/tags/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80/">이더리움</a> <a class="post-tag" href="/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/">트랜잭션</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/ide/">IDE</a> <a class="post-tag" href="/tags/remix/">Remix</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/WebSocket-%EC%B1%95%ED%84%B0-2-%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/"><div class="card-body"> <em class="timeago small" data-ts="1682074980" > 2023-04-21 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>WebSocket 챕터 #2: 웹소켓 프로토콜</h3><div class="text-muted small"><p> 웹소켓 프로토콜 (WebSocket Protocol) WebSocket wire protocol (RFC 6455) HyBi 워킹 그룹에서 개발 상위 구성 요소 (2가지) 연결 매개변수를 협상하는 데 사용되는 오프닝 HTTP 핸드셰이크 메커니즘 텍스트 및 바이너리 데이터의 낮은 오버헤드, 메시지 기반 전송을 ...</p></div></div></a></div><div class="card"> <a href="/posts/%ED%95%91-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%ED%88%B4-%EA%B0%9C%EB%B0%9C/"><div class="card-body"> <em class="timeago small" data-ts="1647780180" > 2022-03-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>핑 모니터링 툴 개발</h3><div class="text-muted small"><p> redniche/Ping-Monitoring 프로젝트 깃허브 링크 소개 인터넷의 특정 네트워크 기기와의 핑테스트를 위해 만들어진 프로그램입니다. 인트라넷 상황에서 내부망을 관제해야할 때 사용하고자 진행했습니다. 하지만 결국 핑 모니터링 툴이기 때문에 모든 환경에서 사용할 수 있습니다. Thread를 사용해 여러 ip주소에 핑테스트를 할 수 있게...</p></div></div></a></div><div class="card"> <a href="/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%95%B1-%EB%B8%8C%EB%9E%98%EC%9D%B8%EB%A7%A4%EB%8B%88%EC%A0%80/"><div class="card-body"> <em class="timeago small" data-ts="1647784980" > 2022-03-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>안드로이드앱-브래인매니저</h3><div class="text-muted small"><p> NeoMindStd/BrainManager 프로젝트 깃허브 링크 소개 사용자가 기억하고자 하는 내용(키워드)을 간격 반복 알고리즘으로 복습시간을 알람. 사용자가 해당 내용을 잊지 않게 하는 안드로이드 앱입니다. 기능이 약간 추상적일 수 있는데 간단히 소개하자면 사용자가 키워드를 입력하고 해당 키워드의 설명을 적어넣고 등록하면 그 키워드와 설명에...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-level3-%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC/" class="btn btn-outline-primary" prompt="이전 글"><p>프로그래머스 level3 입국심사 파이썬 풀이</p></a> <a href="/posts/WebSocket-%EC%B1%95%ED%84%B0-2-%EC%9B%B9%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/" class="btn btn-outline-primary" prompt="다음 글"><p>WebSocket 챕터 #2: 웹소켓 프로토콜</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "yechankun/yechankun.github.io", "data-repo-id": "R_kgDOG4IGyA", "data-category": "Announcements", "data-category-id": "DIC_kwDOG4IGyM4CV-fd", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "ko", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/yechankun">yechankun</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%8B%88%EC%B2%B4/">니체</a> <a class="post-tag" href="/tags/%EC%98%88%EC%B0%AC%EA%B5%B0/">예찬군</a> <a class="post-tag" href="/tags/%EA%B0%9C%EB%B0%9C/">개발</a> <a class="post-tag" href="/tags/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8/">블록체인</a> <a class="post-tag" href="/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a> <a class="post-tag" href="/tags/%EC%9D%B4%EB%8D%94%EB%A6%AC%EC%9B%80/">이더리움</a> <a class="post-tag" href="/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/">트랜잭션</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/ide/">IDE</a> <a class="post-tag" href="/tags/remix/">Remix</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js?v=1682602155"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-Z52C839EYH"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Z52C839EYH'); }); </script>
